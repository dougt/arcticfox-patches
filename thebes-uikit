# HG changeset patch
# User Ted Mielczarek <ted.mielczarek@gmail.com>
# Date 1272373064 14400
# Node ID 37caae1e58336d97ffe999a9bdaa5c559858bcad
# Parent 4c700885dccb4208df6d1547ae05a647301e45d1
imported patch thebes-uikit-tweaks
* * *
imported patch thebes-extra
* * *
fix font metrics
* * *
imported patch thebes-extra
* * *
fix uikit fonts

diff --git a/gfx/src/thebes/Makefile.in b/gfx/src/thebes/Makefile.in
--- a/gfx/src/thebes/Makefile.in
+++ b/gfx/src/thebes/Makefile.in
@@ -103,6 +103,10 @@
 CPPSRCS		+= nsSystemFontsAndroid.cpp
 endif
 
+ifeq ($(MOZ_WIDGET_TOOLKIT),uikit)
+CMMSRCS		= nsSystemFontsUIKit.mm
+endif
+
 EXPORTS         += nsIThebesFontMetrics.h
 
 LOCAL_INCLUDES	= \
diff --git a/gfx/src/thebes/nsSystemFontsUIKit.h b/gfx/src/thebes/nsSystemFontsUIKit.h
new file mode 100644
--- /dev/null
+++ b/gfx/src/thebes/nsSystemFontsUIKit.h
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Corporation code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef _NS_SYSTEMFONTSUIKIT_H_
+#define _NS_SYSTEMFONTSUIKIT_H_
+
+#include <gfxFont.h>
+#include <nsIDeviceContext.h>
+
+class nsSystemFontsUIKit
+{
+public:
+    nsSystemFontsUIKit();
+    nsresult GetSystemFont(nsSystemFontID anID, nsString *aFontName,
+                           gfxFontStyle *aFontStyle) const;
+};
+
+#endif /* _NS_SYSTEMFONTSUIKIT_H_ */
diff --git a/gfx/src/thebes/nsSystemFontsUIKit.mm b/gfx/src/thebes/nsSystemFontsUIKit.mm
new file mode 100644
--- /dev/null
+++ b/gfx/src/thebes/nsSystemFontsUIKit.mm
@@ -0,0 +1,153 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Corporation code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006-2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Jonathan Kew <jfkthame@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <UIKit/UIFont.h>
+#import <UIKit/UIInterface.h>
+
+#include "nsSystemFontsUIKit.h"
+
+
+nsSystemFontsUIKit::nsSystemFontsUIKit()
+{
+}
+
+// copied from gfxQuartzFontCache.mm, maybe should go in a Cocoa utils file somewhere
+static void GetStringForNSString(const NSString *aSrc, nsAString& aDest)
+{
+    aDest.SetLength([aSrc length]);
+    [aSrc getCharacters:aDest.BeginWriting()];
+}
+
+nsresult
+nsSystemFontsUIKit::GetSystemFont(nsSystemFontID aID, nsString *aFontName,
+                                gfxFontStyle *aFontStyle) const
+{
+    // hack for now
+    if (aID == eSystemFont_Window ||
+        aID == eSystemFont_Document)
+    {
+        aFontStyle->style       = FONT_STYLE_NORMAL;
+        aFontStyle->weight      = FONT_WEIGHT_NORMAL;
+        aFontStyle->stretch     = NS_FONT_STRETCH_NORMAL;
+
+        aFontName->AssignLiteral("sans-serif");
+        aFontStyle->size = 14;
+        aFontStyle->systemFont = PR_TRUE;
+
+        return NS_OK;
+    }
+
+    UIFont *font = nsnull;
+    switch (aID) {
+        // css2
+        case eSystemFont_Caption:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Icon: // used in urlbar; tried labelFont, but too small
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Menu:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_MessageBox:
+            font = [UIFont systemFontOfSize:[UIFont smallSystemFontSize]];
+            break;
+        case eSystemFont_SmallCaption:
+            font = [UIFont boldSystemFontOfSize:[UIFont smallSystemFontSize]];
+            break;
+        case eSystemFont_StatusBar:
+            font = [UIFont systemFontOfSize:[UIFont smallSystemFontSize]];
+            break;
+        // css3
+        //case eSystemFont_Window:     = 'sans-serif'
+        //case eSystemFont_Document:   = 'sans-serif'
+        case eSystemFont_Workspace:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Desktop:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Info:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Dialog:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Button:
+            font = [UIFont systemFontOfSize:[UIFont buttonFontSize]];
+            break;
+        case eSystemFont_PullDownMenu:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_List:
+            font = [UIFont systemFontOfSize:[UIFont smallSystemFontSize]];
+            break;
+        case eSystemFont_Field:
+            font = [UIFont systemFontOfSize:[UIFont smallSystemFontSize]];
+            break;
+        // moz
+        case eSystemFont_Tooltips:
+            font = [UIFont systemFontOfSize:0.0];
+            break;
+        case eSystemFont_Widget:
+            font = [UIFont systemFontOfSize:[UIFont smallSystemFontSize]];
+            break;
+        default:
+            // should never hit this
+            return NS_ERROR_FAILURE;
+    }
+
+    NS_ASSERTION(font != nsnull, "failed to find a system font!");
+
+    GetStringForNSString([font familyName], *aFontName);
+    aFontStyle->size = [font pointSize];
+    /*
+    UIFontSymbolicTraits traits = [[font fontDescriptor] symbolicTraits];
+    if (traits & UIFontBoldTrait)
+        aFontStyle->weight = FONT_WEIGHT_BOLD;
+    if (traits & UIFontItalicTrait)
+        aFontStyle->style = FONT_STYLE_ITALIC;
+    aFontStyle->stretch =
+        (traits & UIFontExpandedTrait) ?
+            NS_FONT_STRETCH_EXPANDED : (traits & UIFontCondensedTrait) ?
+                NS_FONT_STRETCH_CONDENSED : NS_FONT_STRETCH_NORMAL;
+    */
+    aFontStyle->systemFont = PR_TRUE;
+
+    return NS_OK;
+}
diff --git a/gfx/src/thebes/nsThebesDeviceContext.cpp b/gfx/src/thebes/nsThebesDeviceContext.cpp
--- a/gfx/src/thebes/nsThebesDeviceContext.cpp
+++ b/gfx/src/thebes/nsThebesDeviceContext.cpp
@@ -81,10 +81,15 @@
 #include "nsSystemFontsBeOS.h"
 static nsSystemFontsBeOS *gSystemFonts = nsnull;
 #elif XP_MACOSX
+#ifdef MOZ_WIDGET_COCOA
 #include "nsSystemFontsMac.h"
+static nsSystemFontsMac *gSystemFonts = nsnull;
+#else
+#include "nsSystemFontsUIKit.h"
+static nsSystemFontsUIKit *gSystemFonts = nsnull;
+#endif
 #include "gfxQuartzSurface.h"
 #include "gfxImageSurface.h"
-static nsSystemFontsMac *gSystemFonts = nsnull;
 #elif defined(MOZ_WIDGET_QT)
 #include "nsSystemFontsQt.h"
 static nsSystemFontsQt *gSystemFonts = nsnull;
@@ -828,8 +833,10 @@
         gSystemFonts = new nsSystemFontsOS2();
 #elif defined(XP_BEOS)
         gSystemFonts = new nsSystemFontsBeOS();
-#elif XP_MACOSX
+#elif defined(MOZ_WIDGET_COCOA)
         gSystemFonts = new nsSystemFontsMac();
+#elif defined(MOZ_WIDGET_UIKIT)
+        gSystemFonts = new nsSystemFontsUIKit();
 #elif defined(MOZ_WIDGET_QT)
         gSystemFonts = new nsSystemFontsQt();
 #elif defined(ANDROID)
diff --git a/gfx/thebes/Makefile.in b/gfx/thebes/Makefile.in
--- a/gfx/thebes/Makefile.in
+++ b/gfx/thebes/Makefile.in
@@ -72,7 +72,7 @@
 	$(NULL)
 endif
 
-ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
+ifneq (,$(filter cocoa uikit,$(MOZ_WIDGET_TOOLKIT)))
 EXPORTS += \
 	gfxPlatformMac.h \
 	gfxQuartzSurface.h \
@@ -348,20 +348,29 @@
 EXTRA_DSO_LDOPTS += $(MOZ_PANGO_LIBS) $(CAIRO_FT_LIBS) -lfontconfig
 endif
 
-ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
+ifneq (,$(filter cocoa uikit,$(MOZ_WIDGET_TOOLKIT)))
 CPPSRCS	+= \
 	gfxQuartzSurface.cpp \
 	gfxQuartzImageSurface.cpp \
 	gfxQuartzPDFSurface.cpp \
 	gfxPlatformMac.cpp \
-	gfxMacFont.cpp \
 	gfxCoreTextShaper.cpp \
 	$(NULL)
 #CPPSRCS +=	gfxPDFSurface.cpp
 CPPSRCS +=      nsUnicodeRange.cpp
 CPPSRCS +=      gfxQuartzNativeDrawing.cpp
 
-CMMSRCS = gfxMacPlatformFontList.mm
+ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
+CPPSRCS += gfxMacFont.cpp
+CMMSRCS += gfxMacPlatformFontList.mm
+endif
+
+ifeq (uikit,$(MOZ_WIDGET_TOOLKIT))
+CMMSRCS += \
+  gfxUIKitPlatformFontList.mm \
+  gfxUIKitFont.mm \
+  $(NULL)
+endif
 
 # Always link with OpenGL/AGL
 EXTRA_DSO_LDOPTS += -framework OpenGL -framework AGL -framework QuickTime -framework AppKit
diff --git a/gfx/thebes/gfxCoreTextShaper.cpp b/gfx/thebes/gfxCoreTextShaper.cpp
--- a/gfx/thebes/gfxCoreTextShaper.cpp
+++ b/gfx/thebes/gfxCoreTextShaper.cpp
@@ -51,13 +51,21 @@
 #include "gfxPlatform.h"
 #include "gfxPlatformMac.h"
 #include "gfxCoreTextShaper.h"
+#ifdef MOZ_WIDGET_COCOA
 #include "gfxMacFont.h"
+#else
+#include "gfxUIKitFont.h"
+#endif
 
 #include "gfxFontTest.h"
 #include "gfxFontUtils.h"
 
 #include "gfxQuartzSurface.h"
+#ifdef MOZ_WIDGET_COCOA
 #include "gfxMacPlatformFontList.h"
+#else
+#include "gfxUIKitPlatformFontList.h"
+#endif
 #include "gfxUserFontSet.h"
 
 #include "nsUnicodeRange.h"
@@ -74,14 +82,20 @@
 CTFontDescriptorRef gfxCoreTextShaper::sDefaultFeaturesDescriptor = NULL;
 CTFontDescriptorRef gfxCoreTextShaper::sDisableLigaturesDescriptor = NULL;
 
-gfxCoreTextShaper::gfxCoreTextShaper(gfxMacFont *aFont)
+gfxCoreTextShaper::gfxCoreTextShaper(gfxCTFont *aFont)
     : gfxFontShaper(aFont)
 {
     // Create our CTFontRef
+#ifdef MOZ_WIDGET_COCOA
     mCTFont = ::CTFontCreateWithPlatformFont(aFont->GetATSFontRef(),
                                              aFont->GetAdjustedSize(),
                                              NULL,
                                              GetDefaultFeaturesDescriptor());
+#else
+    mCTFont = ::CTFontCreateWithName(aFont->GetPostscriptName(),
+                                     aFont->GetAdjustedSize(),
+                                     NULL);
+#endif
 
     // Set up the default attribute dictionary that we will need each time we create a CFAttributedString
     mAttributesDict = ::CFDictionaryCreate(kCFAllocatorDefault,
@@ -165,10 +179,11 @@
     }
 
     CFDictionaryRef attrObj;
+#ifdef MOZ_WIDGET_COCOA
     if (disableLigatures) {
         // For letterspacing (or maybe other situations) we need to make a copy of the CTFont
         // with the ligature feature disabled
-        gfxMacFont *font = static_cast<gfxMacFont*>(mFont);
+        gfxCTFont *font = static_cast<gfxCTFont*>(mFont);
         CTFontRef ctFont =
             CreateCTFontWithDisabledLigatures(font->GetATSFontRef(),
                                               ::CTFontGetSize(mCTFont));
@@ -183,9 +198,12 @@
         // Having created the dict, we're finished with our ligature-disabled CTFontRef
         ::CFRelease(ctFont);
     } else {
+#endif
         attrObj = mAttributesDict;
         ::CFRetain(attrObj);
+#ifdef MOZ_WIDGET_COCOA
     }
+#endif
 
     // Now we can create an attributed string
     CFAttributedStringRef attrStringObj =
@@ -533,6 +551,7 @@
 void
 gfxCoreTextShaper::CreateDefaultFeaturesDescriptor()
 {
+#ifdef MOZ_WIDGET_COCOA
     if (sDefaultFeaturesDescriptor != NULL) {
         return;
     }
@@ -600,8 +619,10 @@
     sDefaultFeaturesDescriptor =
         ::CTFontDescriptorCreateWithAttributes(attributesDict);
     ::CFRelease(attributesDict);
+#endif
 }
 
+#ifdef MOZ_WIDGET_COCOA
 // Create a CTFontRef, with the Common Ligatures feature disabled [static]
 CTFontRef
 gfxCoreTextShaper::CreateCTFontWithDisabledLigatures(ATSFontRef aFontRef, CGFloat aSize)
@@ -656,6 +677,7 @@
     
     return ::CTFontCreateWithPlatformFont(aFontRef, aSize, NULL, sDisableLigaturesDescriptor);
 }
+#endif
 
 void
 gfxCoreTextShaper::Shutdown() // [static]
diff --git a/gfx/thebes/gfxCoreTextShaper.h b/gfx/thebes/gfxCoreTextShaper.h
--- a/gfx/thebes/gfxCoreTextShaper.h
+++ b/gfx/thebes/gfxCoreTextShaper.h
@@ -45,15 +45,24 @@
 #include "gfxFont.h"
 #include "gfxFontUtils.h"
 #include "gfxPlatform.h"
+
+#ifdef MOZ_WIDGET_COCOA
 #include "gfxMacPlatformFontList.h"
-
 #include <Carbon/Carbon.h>
 
 class gfxMacFont;
+typedef gfxMacFont gfxCTFont;
+#else
+#include "gfxUIKitPlatformFontList.h"
+#include <CoreText/CoreText.h>
+
+class gfxUIKitFont;
+typedef gfxUIKitFont gfxCTFont;
+#endif
 
 class gfxCoreTextShaper : public gfxFontShaper {
 public:
-    gfxCoreTextShaper(gfxMacFont *aFont);
+    gfxCoreTextShaper(gfxUIKitFont *aFont);
 
     virtual ~gfxCoreTextShaper();
 
@@ -86,7 +95,9 @@
         return sDefaultFeaturesDescriptor;
     }
 
+#ifdef MOZ_WIDGET_COCOA
     static CTFontRef CreateCTFontWithDisabledLigatures(ATSFontRef aFontRef, CGFloat aSize);
+#endif
 
     // cached font descriptor, created the first time it's needed
     static CTFontDescriptorRef    sDefaultFeaturesDescriptor;
diff --git a/gfx/thebes/gfxFont.h b/gfx/thebes/gfxFont.h
--- a/gfx/thebes/gfxFont.h
+++ b/gfx/thebes/gfxFont.h
@@ -268,6 +268,7 @@
 protected:
     friend class gfxPlatformFontList;
     friend class gfxMacPlatformFontList;
+    friend class gfxUIKitPlatformFontList;
     friend class gfxFcFontEntry;
     friend class gfxFontFamily;
     friend class gfxSingleFaceMacFontFamily;
diff --git a/gfx/thebes/gfxPlatformMac.cpp b/gfx/thebes/gfxPlatformMac.cpp
--- a/gfx/thebes/gfxPlatformMac.cpp
+++ b/gfx/thebes/gfxPlatformMac.cpp
@@ -42,8 +42,14 @@
 #include "gfxQuartzSurface.h"
 #include "gfxQuartzImageSurface.h"
 
+#ifdef MOZ_WIDGET_COCOA
 #include "gfxMacPlatformFontList.h"
 #include "gfxMacFont.h"
+#else
+#include "gfxUIKitPlatformFontList.h"
+#include "gfxUIKitFont.h"
+#endif
+
 #include "gfxCoreTextShaper.h"
 #include "gfxUserFontSet.h"
 
@@ -71,7 +77,11 @@
 gfxPlatformFontList*
 gfxPlatformMac::CreatePlatformFontList()
 {
+#ifdef MOZ_WIDGET_COCOA
     return new gfxMacPlatformFontList();
+#else
+    return new gfxUIKitPlatformFontList();
+#endif
 }
 
 already_AddRefed<gfxASurface>
@@ -201,6 +211,7 @@
 PRInt32 
 gfxPlatformMac::OSXVersion()
 {
+#ifdef MOZ_WIDGET_COCOA
     if (!mOSXVersion) {
         // minor version is not accurate, use gestaltSystemVersionMajor, gestaltSystemVersionMinor, gestaltSystemVersionBugFix for these
         OSErr err = ::Gestalt(gestaltSystemVersion, reinterpret_cast<SInt32*>(&mOSXVersion));
@@ -210,6 +221,9 @@
             mOSXVersion = MAC_OS_X_VERSION_10_4_HEX;
         }
     }
+#else
+    mOSXVersion = MAC_OS_X_VERSION_10_4_HEX;
+#endif
     return mOSXVersion;
 }
 
@@ -233,7 +247,8 @@
     // if the pref setting is disabled, return 0 which effectively disables this feature
     if (!useAntiAliasingThreshold)
         return threshold;
-        
+
+#ifdef MOZ_WIDGET_COCOA
     // value set via Appearance pref panel, "Turn off text smoothing for font sizes xxx and smaller"
     CFNumberRef prefValue = (CFNumberRef)CFPreferencesCopyAppValue(CFSTR("AppleAntiAliasingThreshold"), kCFPreferencesCurrentApplication);
 
@@ -243,6 +258,7 @@
         }
         CFRelease(prefValue);
     }
+#endif
 
     return threshold;
 }
@@ -250,6 +266,7 @@
 qcms_profile *
 gfxPlatformMac::GetPlatformCMSOutputProfile()
 {
+#ifdef MOZ_WIDGET_COCOA
     qcms_profile *profile = nsnull;
     CMProfileRef cmProfile;
     CMProfileLocation *location;
@@ -327,4 +344,7 @@
 fail_close:
     CMCloseProfile(cmProfile);
     return profile;
+#else
+    return nsnull;
+#endif // MOZ_WIDGET_COCOA
 }
diff --git a/gfx/thebes/gfxQuartzPDFSurface.h b/gfx/thebes/gfxQuartzPDFSurface.h
--- a/gfx/thebes/gfxQuartzPDFSurface.h
+++ b/gfx/thebes/gfxQuartzPDFSurface.h
@@ -41,7 +41,11 @@
 #include "gfxASurface.h"
 #include "gfxContext.h"
 
+#ifdef MOZ_WIDGET_COCOA
 #include <Carbon/Carbon.h>
+#else
+#include <CoreGraphics/CoreGraphics.h>
+#endif
 
 class THEBES_API gfxQuartzPDFSurface : public gfxASurface {
 public:
diff --git a/gfx/thebes/gfxQuartzSurface.h b/gfx/thebes/gfxQuartzSurface.h
--- a/gfx/thebes/gfxQuartzSurface.h
+++ b/gfx/thebes/gfxQuartzSurface.h
@@ -42,7 +42,11 @@
 #include "gfxASurface.h"
 #include "gfxImageSurface.h"
 
+#ifdef MOZ_WIDGET_COCOA
 #include <Carbon/Carbon.h>
+#else
+#include <CoreGraphics/CoreGraphics.h>
+#endif
 
 class gfxContext;
 
diff --git a/gfx/thebes/gfxUIKitFont.h b/gfx/thebes/gfxUIKitFont.h
new file mode 100644
--- /dev/null
+++ b/gfx/thebes/gfxUIKitFont.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Corporation code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006-2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Masayuki Nakano <masayuki@d-toybox.com>
+ *   John Daggett <jdaggett@mozilla.com>
+ *   Jonathan Kew <jfkthame@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef GFX_MACFONT_H
+#define GFX_MACFONT_H
+
+#include "gfxFont.h"
+#include "gfxUIKitPlatformFontList.h"
+
+#include "cairo.h"
+
+class gfxUIKitFont : public gfxFont
+{
+public:
+    gfxUIKitFont(UIKitFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
+               PRBool aNeedsBold);
+
+    virtual ~gfxUIKitFont();
+
+    CFStringRef GetPostscriptName() { return mPostscriptName; }
+
+    /* overrides for the pure virtual methods in gfxFont */
+    virtual const gfxFont::Metrics& GetMetrics() {
+        return mMetrics;
+    }
+
+    virtual PRUint32 GetSpaceGlyph() {
+        return mSpaceGlyph;
+    }
+
+    virtual PRBool SetupCairoFont(gfxContext *aContext);
+
+    // override gfxFont table access function to bypass gfxFontEntry cache,
+    // use CGFontRef API to get direct access to system font data
+    //TODO: should we take this?
+    //virtual hb_blob_t *GetFontTable(PRUint32 aTag);
+protected:
+    virtual void CreatePlatformShaper();
+
+    void InitMetrics();
+
+    gfxFloat GetCharWidth(CFDataRef aCmap, PRUnichar aUniChar,
+                          PRUint32 *aGlyphID);
+
+    CFStringRef          mPostscriptName;
+
+    CGFontRef             mCGFont;
+    cairo_font_face_t    *mFontFace;
+    cairo_scaled_font_t  *mScaledFont;
+
+    Metrics               mMetrics;
+    PRUint32              mSpaceGlyph;
+};
+
+#endif /* GFX_MACFONT_H */
diff --git a/gfx/thebes/gfxUIKitFont.mm b/gfx/thebes/gfxUIKitFont.mm
new file mode 100644
--- /dev/null
+++ b/gfx/thebes/gfxUIKitFont.mm
@@ -0,0 +1,262 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Corporation code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006-2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Masayuki Nakano <masayuki@d-toybox.com>
+ *   John Daggett <jdaggett@mozilla.com>
+ *   Jonathan Kew <jfkthame@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "gfxUIKitFont.h"
+#include "gfxCoreTextShaper.h"
+#include "gfxHarfBuzzShaper.h"
+#include "gfxPlatformMac.h"
+#include "gfxContext.h"
+
+#include "cairo-quartz.h"
+
+gfxUIKitFont::gfxUIKitFont(UIKitFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
+                       PRBool aNeedsBold)
+    : gfxFont(aFontEntry, aFontStyle),
+      mPostscriptName(aFontEntry->GetPostscriptName()),
+      mCGFont(nsnull),
+      mFontFace(nsnull),
+      mScaledFont(nsnull)
+{
+    ::CFRetain(mPostscriptName);
+    if (aNeedsBold) {
+        mSyntheticBoldOffset = 1;  // devunit offset when double-striking text to fake boldness
+    }
+
+    // InitMetrics will handle the sizeAdjust factor and set mAdjustedSize
+    gfxFloat size =
+        PR_MAX(mStyle.size, 1.0f);
+    CTFontRef ctFont = ::CTFontCreateWithName(mPostscriptName, size, NULL);
+    mCGFont = ::CTFontCopyGraphicsFont(ctFont, NULL);
+    InitMetrics();
+    if (!mIsValid) {
+        ::CFRelease(ctFont);
+        return;
+    }
+
+    mFontFace = cairo_quartz_font_face_create_for_cgfont(mCGFont);
+    ::CFRelease(ctFont);
+
+    cairo_status_t cairoerr = cairo_font_face_status(mFontFace);
+    if (cairoerr != CAIRO_STATUS_SUCCESS) {
+        mIsValid = PR_FALSE;
+#ifdef DEBUG
+        char warnBuf[1024];
+        sprintf(warnBuf, "Failed to create Cairo font face: %s status: %d",
+                NS_ConvertUTF16toUTF8(GetName()).get(), cairoerr);
+        NS_WARNING(warnBuf);
+#endif
+        return;
+    }
+
+    cairo_matrix_t sizeMatrix, ctm;
+    cairo_matrix_init_identity(&ctm);
+    cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
+
+    cairo_font_options_t *fontOptions = cairo_font_options_create();
+
+    // turn off font anti-aliasing based on user pref setting
+    if (mAdjustedSize <= (float) gfxPlatformMac::GetPlatform()->GetAntiAliasingThreshold()) {
+        cairo_font_options_set_antialias(fontOptions, CAIRO_ANTIALIAS_NONE);
+    }
+
+    mScaledFont = cairo_scaled_font_create(mFontFace, &sizeMatrix, &ctm, fontOptions);
+    cairo_font_options_destroy(fontOptions);
+
+    cairoerr = cairo_scaled_font_status(mScaledFont);
+    if (cairoerr != CAIRO_STATUS_SUCCESS) {
+        mIsValid = PR_FALSE;
+#ifdef DEBUG
+        char warnBuf[1024];
+        sprintf(warnBuf, "Failed to create scaled font: %s status: %d",
+                NS_ConvertUTF16toUTF8(GetName()).get(), cairoerr);
+        NS_WARNING(warnBuf);
+#endif
+    }
+
+    if (FontCanSupportHarfBuzz()) {
+        mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
+    }
+}
+
+gfxUIKitFont::~gfxUIKitFont()
+{
+    ::CFRelease(mPostscriptName);
+    if (mScaledFont) {
+        cairo_scaled_font_destroy(mScaledFont);
+    }
+    if (mFontFace) {
+        cairo_font_face_destroy(mFontFace);
+    }
+
+    // this is documented to be safe if mCGFont is null
+    ::CGFontRelease(mCGFont);
+}
+
+void
+gfxUIKitFont::CreatePlatformShaper()
+{
+    mPlatformShaper = new gfxCoreTextShaper(this);
+}
+
+PRBool
+gfxUIKitFont::SetupCairoFont(gfxContext *aContext)
+{
+    if (cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
+        // Don't cairo_set_scaled_font as that would propagate the error to
+        // the cairo_t, precluding any further drawing.
+        return PR_FALSE;
+    }
+    cairo_set_scaled_font(aContext->GetCairo(), mScaledFont);
+    return PR_TRUE;
+}
+
+void
+gfxUIKitFont::InitMetrics()
+{
+    mIsValid = PR_FALSE;
+    ::memset(&mMetrics, 0, sizeof(mMetrics));
+
+    PRUint32 upem = ::CGFontGetUnitsPerEm(mCGFont);
+    if (!upem) {
+#ifdef DEBUG
+        char warnBuf[1024];
+        sprintf(warnBuf, "Bad font metrics for: %s (no unitsPerEm value)",
+                NS_ConvertUTF16toUTF8(mFontEntry->Name()).get());
+        NS_WARNING(warnBuf);
+#endif
+        return;
+    }
+
+    mAdjustedSize = PR_MAX(mStyle.size, 1.0f);
+    mFUnitsConvFactor = mAdjustedSize / upem;
+    if (!InitMetricsFromSfntTables(mMetrics)) {
+        return;
+    }
+    if (!mIsValid) {
+        return;
+    }
+
+    if (mMetrics.xHeight == 0.0) {
+        mMetrics.xHeight = ::CGFontGetXHeight(mCGFont) * mFUnitsConvFactor;
+    }
+
+    if (mStyle.sizeAdjust != 0.0 && mStyle.size > 0.0 &&
+        mMetrics.xHeight > 0.0) {
+        // apply font-size-adjust, and recalculate metrics
+        gfxFloat aspect = mMetrics.xHeight / mStyle.size;
+        mAdjustedSize = mStyle.GetAdjustedSize(aspect);
+        mMetrics.xHeight = 0.0;
+
+        if (!InitMetricsFromSfntTables(mMetrics)) {
+            return;
+        }
+        if (!mIsValid) {
+            // this shouldn't happen, as we succeeded earlier before applying
+            // the size-adjust factor! But check anyway, for paranoia's sake.
+            return;
+        }
+        if (mMetrics.xHeight == 0.0) {
+            mMetrics.xHeight = ::CGFontGetXHeight(mCGFont) * mFUnitsConvFactor;
+        }
+    }
+
+    mMetrics.emHeight = mAdjustedSize;
+
+    // Measure/calculate additional metrics.
+    CFDataRef cmap =
+        ::CGFontCopyTableForTag(mCGFont, TRUETYPE_TAG('c','m','a','p'));
+
+    PRUint32 glyphID;
+    if (mMetrics.aveCharWidth <= 0) {
+        mMetrics.aveCharWidth = GetCharWidth(cmap, 'x', &glyphID);
+        if (glyphID == 0) {
+            // we didn't find 'x', so use maxAdvance rather than zero
+            mMetrics.aveCharWidth = mMetrics.maxAdvance;
+        }
+    }
+    mMetrics.aveCharWidth += mSyntheticBoldOffset;
+    mMetrics.maxAdvance += mSyntheticBoldOffset;
+
+    mMetrics.spaceWidth = GetCharWidth(cmap, ' ', &glyphID);
+    if (glyphID == 0) {
+        // no space glyph?!
+        mMetrics.spaceWidth = mMetrics.aveCharWidth;
+    }
+    mSpaceGlyph = glyphID;
+
+    mMetrics.zeroOrAveCharWidth = GetCharWidth(cmap, '0', &glyphID);
+    if (glyphID == 0) {
+        mMetrics.zeroOrAveCharWidth = mMetrics.aveCharWidth;
+    }
+
+    if (cmap) {
+        ::CFRelease(cmap);
+    }
+
+    CalculateDerivedMetrics(mMetrics);
+
+    SanitizeMetrics(&mMetrics, mFontEntry->mIsBadUnderlineFont);
+}
+
+gfxFloat
+gfxUIKitFont::GetCharWidth(CFDataRef aCmap, PRUnichar aUniChar,
+                         PRUint32 *aGlyphID)
+{
+    CGGlyph glyph = 0;
+    
+    if (aCmap) {
+        glyph = gfxFontUtils::MapCharToGlyph(::CFDataGetBytePtr(aCmap),
+                                             ::CFDataGetLength(aCmap),
+                                             aUniChar);
+    }
+
+    if (aGlyphID) {
+        *aGlyphID = glyph;
+    }
+
+    if (glyph) {
+        int advance;
+        if (::CGFontGetGlyphAdvances(mCGFont, &glyph, 1, &advance)) {
+            return advance * mFUnitsConvFactor;
+        }
+    }
+
+    return 0;
+}
diff --git a/gfx/thebes/gfxUIKitPlatformFontList.h b/gfx/thebes/gfxUIKitPlatformFontList.h
new file mode 100644
--- /dev/null
+++ b/gfx/thebes/gfxUIKitPlatformFontList.h
@@ -0,0 +1,118 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Corporation code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006-2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ted Mielczarek <ted.mielczarek@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef gfxUIKitPlatformFontList_H_
+#define gfxUIKitPlatformFontList_H_
+
+#include "nsDataHashtable.h"
+#include "nsRefPtrHashtable.h"
+
+#include "gfxPlatformFontList.h"
+#include "gfxPlatform.h"
+
+#include "nsUnicharUtils.h"
+#include "nsTArray.h"
+
+#include <CoreText/CoreText.h>
+
+class gfxUIKitPlatformFontList;
+
+// a single member of a font family (i.e. a single face, such as Times Italic)
+class UIKitFontEntry : public gfxFontEntry
+{
+public:
+    friend class gfxUIKitPlatformFontList;
+
+    UIKitFontEntry(const nsAString& aPostscriptName, PRInt32 aWeight,
+                   gfxFontFamily *aFamily, PRBool aIsStandardFace = PR_FALSE);
+    ~UIKitFontEntry() {
+        ::CFRelease(mPostscriptName);
+    }
+
+    nsresult ReadCMAP();
+
+    CFStringRef GetPostscriptName() { return mPostscriptName; }
+
+protected:
+    // for use with data fonts
+    UIKitFontEntry(const nsAString& aPostscriptName,
+                   PRUint16 aWeight, PRUint16 aStretch, PRUint32 aItalicStyle,
+                   gfxUserFontData *aUserFontData);
+
+    virtual nsresult GetFontTable(PRUint32 aTableTag, nsTArray<PRUint8>& aBuffer);
+
+    virtual gfxFont* CreateFontInstance(const gfxFontStyle *aFontStyle, PRBool aNeedsBold);
+
+    CFStringRef mPostscriptName;
+};
+
+class gfxUIKitPlatformFontList : public gfxPlatformFontList {
+public:
+    static gfxUIKitPlatformFontList* PlatformFontList() {
+        return static_cast<gfxUIKitPlatformFontList*>(sPlatformFontList);
+    }
+
+    static PRInt32 AppleWeightToCSSWeight(PRInt32 aAppleWeight);
+
+    virtual gfxFontEntry* GetDefaultFont(const gfxFontStyle* aStyle, PRBool& aNeedsBold);
+
+    virtual PRBool GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName);
+
+    virtual gfxFontEntry* LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
+                                          const nsAString& aFontName);
+    
+    virtual gfxFontEntry* MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
+                                           const PRUint8 *aFontData, PRUint32 aLength);
+
+    void ClearPrefFonts() { mPrefFonts.Clear(); }
+
+private:
+    friend class gfxPlatformMac;
+
+    gfxUIKitPlatformFontList();
+
+    // initialize font lists
+    virtual void InitFontList();
+
+    // special case font faces treated as font families (set via prefs)
+    void InitSingleFaceList();
+
+    // eliminate faces which have the same ATS font reference
+    void EliminateDuplicateFaces(const nsAString& aFamilyName);
+};
+
+#endif /* gfxUIKitPlatformFontList_H_ */
diff --git a/gfx/thebes/gfxUIKitPlatformFontList.mm b/gfx/thebes/gfxUIKitPlatformFontList.mm
new file mode 100644
--- /dev/null
+++ b/gfx/thebes/gfxUIKitPlatformFontList.mm
@@ -0,0 +1,496 @@
+/* -*- Mode: ObjC; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: BSD
+ *
+ * Copyright (C) 2006-2009 Mozilla Corporation.  All rights reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Masayuki Nakano <masayuki@d-toybox.com>
+ *   John Daggett <jdaggett@mozilla.com>
+ *   Jonathan Kew <jfkthame@gmail.com>
+ *
+ * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
+ *     its contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <Foundation/Foundation.h>
+#import <UIKit/UIFont.h>
+
+#include "gfxPlatformMac.h"
+#include "gfxUIKitPlatformFontList.h"
+#include "gfxUIKitFont.h"
+#include "gfxUserFontSet.h"
+
+#include "nsServiceManagerUtils.h"
+#include "nsTArray.h"
+
+#include "nsDirectoryServiceUtils.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsISimpleEnumerator.h"
+
+#include <unistd.h>
+#include <time.h>
+
+class nsAutoreleasePool {
+public:
+    nsAutoreleasePool()
+    {
+        mLocalPool = [[NSAutoreleasePool alloc] init];
+    }
+    ~nsAutoreleasePool()
+    {
+        [mLocalPool release];
+    }
+private:
+    NSAutoreleasePool *mLocalPool;
+};
+
+// font info loader constants
+static const PRUint32 kDelayBeforeLoadingCmaps = 8 * 1000; // 8secs
+static const PRUint32 kIntervalBetweenLoadingCmaps = 150; // 150ms
+static const PRUint32 kNumFontsPerSlice = 10; // read in info 10 fonts at a time
+
+
+static void GetStringForNSString(const NSString *aSrc, nsAString& aDist)
+{
+    aDist.SetLength([aSrc length]);
+    [aSrc getCharacters:aDist.BeginWriting()];
+}
+
+static NSString* GetNSStringForString(const nsAString& aSrc)
+{
+    return [NSString stringWithCharacters:aSrc.BeginReading()
+                     length:aSrc.Length()];
+}
+
+#ifdef PR_LOGGING
+static PRLogModuleInfo *gFontInfoLog = PR_NewLogModule("fontInfoLog");
+#endif /* PR_LOGGING */
+
+#define LOG(args) PR_LOG(gFontInfoLog, PR_LOG_DEBUG, args)
+#define LOG_ENABLED() PR_LOG_TEST(gFontInfoLog, PR_LOG_DEBUG)
+
+/* UIKitFontEntry */
+#pragma mark-
+
+UIKitFontEntry::UIKitFontEntry(const nsAString& aPostscriptName,
+                               PRInt32 aWeight,
+                               gfxFontFamily *aFamily,
+                               PRBool aIsStandardFace)
+    : gfxFontEntry(aPostscriptName, aFamily, aIsStandardFace),
+      mPostscriptName((CFStringRef)GetNSStringForString(aPostscriptName))
+{
+    mWeight = aWeight;
+    ::CFRetain(mPostscriptName);
+}
+
+UIKitFontEntry::UIKitFontEntry(const nsAString& aPostscriptName,
+                               PRUint16 aWeight, PRUint16 aStretch, PRUint32 aItalicStyle,
+                               gfxUserFontData *aUserFontData)
+    : gfxFontEntry(aPostscriptName),
+      mPostscriptName((CFStringRef)GetNSStringForString(aPostscriptName))
+{
+    ::CFRetain(mPostscriptName);
+    // xxx - stretch is basically ignored for now
+
+    mUserFontData = aUserFontData;
+    mWeight = aWeight;
+    mStretch = aStretch;
+    mFixedPitch = PR_FALSE; // xxx - do we need this for downloaded fonts?
+    mItalic = (aItalicStyle & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
+    mIsUserFont = aUserFontData != nsnull;
+}
+
+// ATSUI requires AAT-enabled fonts to render complex scripts correctly.
+// For now, simple clear out the cmap codepoints for fonts that have
+// codepoints for complex scripts. (Bug 361986)
+// Core Text is similar, but can render Arabic using OpenType fonts as well.
+
+enum eComplexScript {
+    eComplexScriptArabic,
+    eComplexScriptIndic,
+    eComplexScriptTibetan
+};
+
+struct ScriptRange {
+    eComplexScript   script;
+    PRUint32         rangeStart;
+    PRUint32         rangeEnd;
+};
+
+const ScriptRange gScriptsThatRequireShaping[] = {
+    { eComplexScriptArabic, 0x0600, 0x077F },   // Basic Arabic and Arabic Supplement
+    { eComplexScriptIndic, 0x0900, 0x0D7F },     // Indic scripts - Devanagari, Bengali, ..., Malayalam
+    { eComplexScriptTibetan, 0x0F00, 0x0FFF }     // Tibetan
+    // Thai seems to be "renderable" without AAT morphing tables
+    // xxx - Lao, Khmer?
+};
+
+nsresult
+UIKitFontEntry::ReadCMAP()
+{
+    // attempt this once, if errors occur leave a blank cmap
+    if (mCmapInitialized)
+        return NS_OK;
+    mCmapInitialized = PR_TRUE;
+
+    PRUint32 kCMAP = TRUETYPE_TAG('c','m','a','p');
+
+    nsAutoTArray<PRUint8,16384> cmap;
+    if (GetFontTable(kCMAP, cmap) != NS_OK)
+        return NS_ERROR_FAILURE;
+
+    PRPackedBool  unicodeFont, symbolFont; // currently ignored
+    nsresult rv = gfxFontUtils::ReadCMAP(cmap.Elements(), cmap.Length(),
+                                         mCharacterMap, mUVSOffset,
+                                         unicodeFont, symbolFont);
+
+    if (NS_FAILED(rv)) {
+        mCharacterMap.reset();
+        return rv;
+    }
+
+    PR_LOG(gFontInfoLog, PR_LOG_DEBUG, ("(fontinit-cmap) psname: %s, size: %d\n",
+                                        NS_ConvertUTF16toUTF8(mName).get(), mCharacterMap.GetSize()));
+
+    return rv;
+}
+
+nsresult
+UIKitFontEntry::GetFontTable(PRUint32 aTableTag, nsTArray<PRUint8>& aBuffer)
+{
+    nsAutoreleasePool localPool;
+
+    CTFontRef ctFont = ::CTFontCreateWithName(mPostscriptName, 10, NULL);
+    CFDataRef table  = ::CTFontCopyTable(ctFont, aTableTag, kCTFontTableOptionNoOptions);
+    ::CFRelease(ctFont);
+    if (!table)
+        return NS_ERROR_FAILURE;
+
+    if (!aBuffer.AppendElements(CFDataGetLength(table))) {
+        ::CFRelease(table);
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    CFDataGetBytes(table,
+                   CFRangeMake(0, CFDataGetLength(table)),
+                   aBuffer.Elements());
+    ::CFRelease(table);
+
+    return NS_OK;
+}
+
+gfxFont*
+UIKitFontEntry::CreateFontInstance(const gfxFontStyle *aFontStyle, PRBool aNeedsBold)
+{
+    return new gfxUIKitFont(this, aFontStyle, aNeedsBold);
+}
+
+
+/* gfxUIKitFontFamily */
+#pragma mark-
+
+class gfxUIKitFontFamily : public gfxFontFamily
+{
+public:
+    gfxUIKitFontFamily(nsAString& aName) :
+        gfxFontFamily(aName)
+    {}
+
+    virtual ~gfxUIKitFontFamily() {}
+
+    virtual void LocalizedName(nsAString& aLocalizedName);
+
+    virtual void FindStyleVariations();
+};
+
+void
+gfxUIKitFontFamily::LocalizedName(nsAString& aLocalizedName)
+{
+    aLocalizedName = mName;
+}
+
+void
+gfxUIKitFontFamily::FindStyleVariations()
+{
+    if (mHasStyles)
+        return;
+
+    nsAutoreleasePool localPool;
+
+    NSString *family = GetNSStringForString(mName);
+    for (NSString* psname in [UIFont fontNamesForFamilyName:family]) {
+        PRBool isStandardFace = PR_FALSE;
+        // make a nsString
+        nsAutoString postscriptFontName;
+        GetStringForNSString(psname, postscriptFontName);
+
+        CTFontRef ctFont = ::CTFontCreateWithName((CFStringRef)psname, 10, NULL);
+        CFDictionaryRef traits = ::CTFontCopyTraits(ctFont);
+        NSString* facename = (NSString*)CTFontCopyName(ctFont, kCTFontStyleNameKey);
+        if ([facename isEqualToString:@"Regular"] ||
+            [facename isEqualToString:@"Bold"] ||
+            [facename isEqualToString:@"Italic"] ||
+            [facename isEqualToString:@"Oblique"] ||
+            [facename isEqualToString:@"Bold Italic"] ||
+            [facename isEqualToString:@"Bold Oblique"])
+        {
+            isStandardFace = PR_TRUE;
+        }
+        ::CFRelease(ctFont);
+
+        CFNumberRef weight = (CFNumberRef)::CFDictionaryGetValue(traits, kCTFontWeightTrait);
+        double ctWeight;
+        CFNumberGetValue(weight, kCFNumberDoubleType, &ctWeight);
+        ::CFRelease(traits);
+        ::CFRelease(weight);
+
+        PRInt32 cssWeight = PRInt32(round(((ctWeight + 1.0) / 2.0) * 800.0 + 100.0));
+        //printf("FindStyleVariations: %s: ctWeight: %lf, cssWeight: %d\n",
+        //       [psname UTF8String], ctWeight, cssWeight);
+        // create a font entry
+        UIKitFontEntry *fontEntry = new UIKitFontEntry(postscriptFontName,
+                                                       cssWeight, this, isStandardFace);
+        if (!fontEntry) break;
+
+        // insert into font entry array of family
+        AddFontEntry(fontEntry);
+    }
+
+    SortAvailableFonts();
+    SetHasStyles(PR_TRUE);
+
+    if (mIsBadUnderlineFamily) {
+        SetBadUnderlineFonts();
+    }
+}
+
+/* gfxSingleFaceMacFontFamily */
+#pragma mark-
+
+class gfxSingleFaceMacFontFamily : public gfxFontFamily
+{
+public:
+    gfxSingleFaceMacFontFamily(nsAString& aName) :
+        gfxFontFamily(aName)
+    {}
+
+    virtual ~gfxSingleFaceMacFontFamily() {}
+
+    virtual void LocalizedName(nsAString& aLocalizedName);
+
+    virtual void ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList);
+};
+
+void
+gfxSingleFaceMacFontFamily::LocalizedName(nsAString& aLocalizedName)
+{
+    nsAutoreleasePool localPool;
+
+    if (!HasOtherFamilyNames()) {
+        aLocalizedName = mName;
+        return;
+    }
+
+    // failed to get localized name, just use the canonical one
+    aLocalizedName = mName;
+}
+
+void
+gfxSingleFaceMacFontFamily::ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList)
+{
+    if (mOtherFamilyNamesInitialized)
+        return;
+
+    gfxFontEntry *fe = mAvailableFonts[0];
+    if (!fe)
+        return;
+
+    const PRUint32 kNAME = TRUETYPE_TAG('n','a','m','e');
+    nsAutoTArray<PRUint8,8192> buffer;
+
+    if (fe->GetFontTable(kNAME, buffer) != NS_OK)
+        return;
+
+    mHasOtherFamilyNames = ReadOtherFamilyNamesForFace(aPlatformFontList,
+                                                       buffer,
+                                                       PR_TRUE);
+    mOtherFamilyNamesInitialized = PR_TRUE;
+}
+
+
+/* gfxUIKitPlatformFontList */
+#pragma mark-
+
+gfxUIKitPlatformFontList::gfxUIKitPlatformFontList() :
+    gfxPlatformFontList(PR_FALSE)
+{
+    // this should always be available (though we won't actually fail if it's missing,
+    // we'll just end up doing a search and then caching the new result instead)
+    mReplacementCharFallbackFamily = NS_LITERAL_STRING("Helvetica");
+}
+
+void
+gfxUIKitPlatformFontList::InitFontList()
+{
+    printf("gfxUIKitPlatformFontList::InitFontList()\n");
+    nsAutoreleasePool localPool;
+
+    // reset font lists
+    gfxPlatformFontList::InitFontList();
+    
+    nsAutoString availableFamilyName;
+    NSString *availableFamily = nil;
+    for (availableFamily in [UIFont familyNames]) {
+        //printf("Font family: %s\n", [availableFamily UTF8String]);
+
+        GetStringForNSString(availableFamily, availableFamilyName);
+        // create a family entry
+        gfxFontFamily *familyEntry = new gfxUIKitFontFamily(availableFamilyName);
+        if (!familyEntry) break;
+
+        // add the family entry to the hash table
+        ToLowerCase(availableFamilyName);
+        mFontFamilies.Put(availableFamilyName, familyEntry);
+
+        // check the bad underline blacklist
+        if (mBadUnderlineFamilyNames.Contains(availableFamilyName))
+            familyEntry->SetBadUnderlineFamily();
+    }
+
+    InitSingleFaceList();
+
+    // to avoid full search of font name tables, seed the other names table with localized names from
+    // some of the prefs fonts which are accessed via their localized names.  changes in the pref fonts will only cause
+    // a font lookup miss earlier. this is a simple optimization, it's not required for correctness
+    PreloadNamesList();
+
+    // start the delayed cmap loader
+    StartLoader(kDelayBeforeLoadingCmaps, kIntervalBetweenLoadingCmaps);
+}
+
+void
+gfxUIKitPlatformFontList::InitSingleFaceList()
+{
+    nsAutoTArray<nsString, 10> singleFaceFonts;
+    gfxFontUtils::GetPrefsFontList("font.single-face-list", singleFaceFonts);
+
+    PRUint32 numFonts = singleFaceFonts.Length();
+    for (PRUint32 i = 0; i < numFonts; i++) {
+        PR_LOG(gFontInfoLog, PR_LOG_DEBUG, ("(fontlist-singleface) face name: %s\n",
+                                            NS_ConvertUTF16toUTF8(singleFaceFonts[i]).get()));
+        gfxFontEntry *fontEntry = LookupLocalFont(nsnull, singleFaceFonts[i]);
+        if (fontEntry) {
+            nsAutoString familyName, key;
+            familyName = singleFaceFonts[i];
+            GenerateFontListKey(familyName, key);
+            PR_LOG(gFontInfoLog, PR_LOG_DEBUG, ("(fontlist-singleface) family name: %s, key: %s\n",
+                   NS_ConvertUTF16toUTF8(familyName).get(), NS_ConvertUTF16toUTF8(key).get()));
+
+            // add only if doesn't exist already
+            PRBool found;
+            gfxFontFamily *familyEntry;
+            if (!(familyEntry = mFontFamilies.GetWeak(key, &found))) {
+                familyEntry = new gfxSingleFaceMacFontFamily(familyName);
+                familyEntry->AddFontEntry(fontEntry);
+                familyEntry->SetHasStyles(PR_TRUE);
+                mFontFamilies.Put(key, familyEntry);
+                fontEntry->mFamily = familyEntry;
+                PR_LOG(gFontInfoLog, PR_LOG_DEBUG, ("(fontlist-singleface) added new family\n",
+                       NS_ConvertUTF16toUTF8(familyName).get(), NS_ConvertUTF16toUTF8(key).get()));
+            }
+        }
+    }
+}
+
+void
+gfxUIKitPlatformFontList::EliminateDuplicateFaces(const nsAString& aFamilyName)
+{
+}
+
+PRBool
+gfxUIKitPlatformFontList::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
+{
+    gfxFontFamily *family = FindFamily(aFontName);
+    if (family) {
+        family->LocalizedName(aFamilyName);
+        return PR_TRUE;
+    }
+
+    return PR_FALSE;
+}
+
+gfxFontEntry*
+gfxUIKitPlatformFontList::GetDefaultFont(const gfxFontStyle* aStyle, PRBool& aNeedsBold)
+{
+    nsAutoreleasePool localPool;
+
+    NSString *defaultFamily = [[UIFont systemFontOfSize:aStyle->size] familyName];
+    nsAutoString familyName;
+
+    GetStringForNSString(defaultFamily, familyName);
+    return FindFontForFamily(familyName, aStyle, aNeedsBold);
+}
+
+gfxFontEntry*
+gfxUIKitPlatformFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
+                                          const nsAString& aFontName)
+{
+    nsAutoreleasePool localPool;
+
+    NSString *faceName = GetNSStringForString(aFontName);
+
+    UIKitFontEntry *newFontEntry;
+    if (aProxyEntry) {
+        PRUint16 w = aProxyEntry->mWeight;
+        NS_ASSERTION(w >= 100 && w <= 900, "bogus font weight value!");
+
+        newFontEntry =
+            new UIKitFontEntry(aFontName,
+                               w, aProxyEntry->mStretch,
+                               aProxyEntry->mItalic ?
+                                   FONT_STYLE_ITALIC : FONT_STYLE_NORMAL,
+                               nsnull);
+    } else {
+        newFontEntry =
+            new UIKitFontEntry(aFontName,
+                               400, 0, FONT_STYLE_NORMAL, nsnull);
+    }
+
+    return newFontEntry;
+}
+
+gfxFontEntry*
+gfxUIKitPlatformFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
+                                           const PRUint8 *aFontData,
+                                           PRUint32 aLength)
+{
+    //XXX: are there enough APIs to do this?
+    return nsnull;
+}
+
