diff --git a/widget/src/Makefile.in b/widget/src/Makefile.in
--- a/widget/src/Makefile.in
+++ b/widget/src/Makefile.in
@@ -46,7 +46,7 @@
 
 DIRS		= xpwidgets
 
-ifneq (,$(filter beos os2 cocoa qt,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter beos os2 cocoa qt uikit,$(MOZ_WIDGET_TOOLKIT)))
 DIRS		+= $(MOZ_WIDGET_TOOLKIT)
 endif
 
diff --git a/widget/src/uikit/Makefile.in b/widget/src/uikit/Makefile.in
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/Makefile.in
@@ -0,0 +1,76 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org Code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= widget
+LIBRARY_NAME	= widget_uikit
+EXPORT_LIBRARY	= 1
+IS_COMPONENT	= 1
+MODULE_NAME	= nsWidgetUIKitModule
+XPIDL_MODULE	= widget_uikit
+GRE_MODULE	= 1
+LIBXUL_LIBRARY = 1
+
+
+CMMSRCS = \
+  nsAppShell.mm \
+  nsWidgetFactory.mm \
+  $(NULL)
+
+SHARED_LIBRARY_LIBS = ../xpwidgets/libxpwidgets_s.a
+
+EXTRA_DSO_LDOPTS += \
+  $(MOZ_UNICHARUTIL_LIBS) \
+  $(TK_LIBS) \
+  $(call EXPAND_LIBNAME_PATH,gkgfx,$(DEPTH)/gfx/src) \
+  $(MOZ_COMPONENT_LIBS) \
+  -lthebes \
+  $(QCMS_LIBS) \
+  $(NULL)
+
+include $(topsrcdir)/config/rules.mk
+
+LOCAL_INCLUDES	= \
+  $(TK_CFLAGS) \
+  -I$(srcdir)/../xpwidgets \
+  $(NULL)
diff --git a/widget/src/uikit/nsAppShell.h b/widget/src/uikit/nsAppShell.h
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsAppShell.h
@@ -0,0 +1,95 @@
+/* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is a Cocoa widget run loop and event implementation.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Runs the main native UIKit run loop, interrupting it as needed to process
+ * Gecko events.  
+ */
+
+#ifndef nsAppShell_h_
+#define nsAppShell_h_
+
+//class nsCocoaWindow;
+
+#include "nsBaseAppShell.h"
+#include "nsTArray.h"
+
+@class AppShellDelegate;
+
+class nsAppShell : public nsBaseAppShell
+{
+public:
+  NS_IMETHOD ResumeNative(void);
+	
+  nsAppShell();
+
+  nsresult Init();
+
+  NS_IMETHOD Run(void);
+  NS_IMETHOD Exit(void);
+  NS_IMETHOD OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,
+                                PRUint32 aRecursionDepth);
+  NS_IMETHOD AfterProcessNextEvent(nsIThreadInternal *aThread,
+                                   PRUint32 aRecursionDepth);
+
+  // public only to be visible to Objective-C code that must call it
+  void WillTerminate();
+
+protected:
+  virtual ~nsAppShell();
+
+  virtual void ScheduleNativeEventCallback();
+  virtual PRBool ProcessNextNativeEvent(PRBool aMayWait);
+
+  PRBool InGeckoMainEventLoop();
+
+  static void ProcessGeckoEvents(void* aInfo);
+
+protected:
+  AppShellDelegate*  mDelegate;
+  CFRunLoopRef       mCFRunLoop;
+  CFRunLoopSourceRef mCFRunLoopSource;
+
+  PRPackedBool       mRunningEventLoop;
+
+  PRPackedBool       mStarted;
+  PRPackedBool       mTerminated;
+  PRPackedBool       mNotifiedWillTerminate;
+  PRPackedBool       mSkippedNativeCallback;
+};
+
+#endif // nsAppShell_h_
diff --git a/widget/src/uikit/nsAppShell.mm b/widget/src/uikit/nsAppShell.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsAppShell.mm
@@ -0,0 +1,622 @@
+/* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is a Cocoa widget run loop and event implementation.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <UIKit/UIKit.h>
+#include <dlfcn.h>
+
+#include "nsAppShell.h"
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsString.h"
+#include "nsIRollupListener.h"
+#include "nsIWidget.h"
+#include "nsThreadUtils.h"
+#include "nsIWindowMediator.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIInterfaceRequestor.h"
+#include "nsIWebBrowserChrome.h"
+
+#include "npapi.h"
+
+// AppShellDelegate
+//
+// Cocoa bridge class.  An object of this class is registered to receive
+// notifications.
+//
+@interface AppShellDelegate : NSObject
+{
+  @private
+    nsAppShell* mAppShell;
+}
+
+- (id)initWithAppShell:(nsAppShell*)aAppShell;
+- (void)applicationWillTerminate:(NSNotification*)aNotification;
+- (void)beginMenuTracking:(NSNotification*)aNotification;
+@end
+
+// nsAppShell implementation
+
+NS_IMETHODIMP
+nsAppShell::ResumeNative(void)
+{
+  nsresult retval = nsBaseAppShell::ResumeNative();
+  if (NS_SUCCEEDED(retval) && (mSuspendNativeCount == 0) &&
+      mSkippedNativeCallback)
+  {
+    mSkippedNativeCallback = PR_FALSE;
+    ScheduleNativeEventCallback();
+  }
+  return retval;
+}
+
+nsAppShell::nsAppShell()
+, mDelegate(nsnull)
+, mCFRunLoop(NULL)
+, mCFRunLoopSource(NULL)
+, mRunningEventLoop(PR_FALSE)
+, mStarted(PR_FALSE)
+, mTerminated(PR_FALSE)
+, mNotifiedWillTerminate(PR_FALSE)
+{
+}
+
+nsAppShell::~nsAppShell()
+{
+  if (mCFRunLoop) {
+    if (mCFRunLoopSource) {
+      ::CFRunLoopRemoveSource(mCFRunLoop, mCFRunLoopSource,
+                              kCFRunLoopCommonModes);
+      ::CFRelease(mCFRunLoopSource);
+    }
+    ::CFRelease(mCFRunLoop);
+  }
+
+  [mDelegate release];
+}
+
+// Init
+//
+// public
+nsresult
+nsAppShell::Init()
+{
+  // No event loop is running yet (unless Camino is running, or another
+  // embedding app that uses NSApplicationMain()).
+  NSAutoreleasePool* localPool = [[NSAutoreleasePool alloc] init];
+
+  mDelegate = [[AppShellDelegate alloc] initWithAppShell:this];
+  NS_ENSURE_STATE(mDelegate);
+
+  // Add a CFRunLoopSource to the main native run loop.  The source is
+  // responsible for interrupting the run loop when Gecko events are ready.
+
+  mCFRunLoop = [[NSRunLoop currentRunLoop] getCFRunLoop];
+  NS_ENSURE_STATE(mCFRunLoop);
+  ::CFRetain(mCFRunLoop);
+
+  CFRunLoopSourceContext context;
+  bzero(&context, sizeof(context));
+  // context.version = 0;
+  context.info = this;
+  context.perform = ProcessGeckoEvents;
+  
+  mCFRunLoopSource = ::CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);
+  NS_ENSURE_STATE(mCFRunLoopSource);
+
+  ::CFRunLoopAddSource(mCFRunLoop, mCFRunLoopSource, kCFRunLoopCommonModes);
+
+  rv = nsBaseAppShell::Init();
+
+  [localPool release];
+
+  return rv;
+}
+
+// ProcessGeckoEvents
+//
+// The "perform" target of mCFRunLoop, called when mCFRunLoopSource is
+// signalled from ScheduleNativeEventCallback.
+//
+// Arrange for Gecko events to be processed on demand (in response to a call
+// to ScheduleNativeEventCallback(), if processing of Gecko events via "native
+// methods" hasn't been suspended).  This happens in NativeEventCallback().
+//
+// protected static
+void
+nsAppShell::ProcessGeckoEvents(void* aInfo)
+{
+  nsAppShell* self = static_cast<nsAppShell*> (aInfo);
+  /*
+  if (self->mRunningEventLoop) {
+    self->mRunningEventLoop = PR_FALSE;
+
+    // The run loop may be sleeping -- [NSRunLoop runMode:...]
+    // won't return until it's given a reason to wake up.  Awaken it by
+    // posting a bogus event.  There's no need to make the event
+    // presentable.
+    [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined
+                                        location:NSMakePoint(0,0)
+                                   modifierFlags:0
+                                       timestamp:0
+                                    windowNumber:0
+                                         context:NULL
+                                         subtype:0
+                                           data1:0
+                                           data2:0]
+             atStart:NO];
+  }
+  */
+
+}
+
+// WillTerminate
+//
+// Called by the AppShellDelegate when an NSApplicationWillTerminate
+// notification is posted.  After this method is called, native events should
+// no longer be processed.  The NSApplicationWillTerminate notification is
+// only posted when [NSApp terminate:] is called, which doesn't happen on a
+// "normal" application quit.
+//
+// public
+void
+nsAppShell::WillTerminate()
+{
+  mNotifiedWillTerminate = PR_TRUE;
+  if (mTerminated)
+    return;
+  mTerminated = PR_TRUE;
+
+  // Calling [NSApp terminate:] causes (among other things) an
+  // NSApplicationWillTerminate notification to be posted and the main run
+  // loop to die before returning (in the call to [NSApp run]).  So this is
+  // our last crack at processing any remaining Gecko events.
+  NS_ProcessPendingEvents(NS_GetCurrentThread());
+
+  // Unless we call nsBaseAppShell::Exit() here, it might not get called
+  // at all.
+  nsBaseAppShell::Exit();
+}
+
+// ScheduleNativeEventCallback
+//
+// Called (possibly on a non-main thread) when Gecko has an event that
+// needs to be processed.  The Gecko event needs to be processed on the
+// main thread, so the native run loop must be interrupted.
+//
+// In nsBaseAppShell.cpp, the mNativeEventPending variable is used to
+// ensure that ScheduleNativeEventCallback() is called no more than once
+// per call to NativeEventCallback().  ProcessGeckoEvents() can skip its
+// call to NativeEventCallback() if processing of Gecko events by native
+// means is suspended (using nsIAppShell::SuspendNative()), which will
+// suspend calls from nsBaseAppShell::OnDispatchedEvent() to
+// ScheduleNativeEventCallback().  But when Gecko event processing by
+// native means is resumed (in ResumeNative()), an extra call is made to
+// ScheduleNativeEventCallback() (from ResumeNative()).  This triggers
+// another call to ProcessGeckoEvents(), which calls NativeEventCallback(),
+// and nsBaseAppShell::OnDispatchedEvent() resumes calling
+// ScheduleNativeEventCallback().
+//
+// protected virtual
+void
+nsAppShell::ScheduleNativeEventCallback()
+{
+  if (mTerminated)
+    return;
+
+  // Each AddRef() here is normally balanced by exactly one Release() in
+  // ProcessGeckoEvents().  But there are exceptions, for which see
+  // ProcessGeckoEvents() and Exit().
+  NS_ADDREF_THIS();
+  PR_AtomicIncrement(&mNativeEventScheduledDepth);
+
+  // This will invoke ProcessGeckoEvents on the main thread.
+  ::CFRunLoopSourceSignal(mCFRunLoopSource);
+  ::CFRunLoopWakeUp(mCFRunLoop);
+}
+
+// ProcessNextNativeEvent
+//
+// If aMayWait is false, process a single native event.  If it is true, run
+// the native run loop until stopped by ProcessGeckoEvents.
+//
+// Returns true if more events are waiting in the native event queue.
+//
+// But (now that we're using [NSRunLoop runMode:beforeDate:]) it's too
+// expensive to call ProcessNextNativeEvent() many times in a row (in a
+// tight loop), so we never return true more than kHadMoreEventsCountMax
+// times in a row.  This doesn't seem to cause native event starvation.
+//
+// protected virtual
+PRBool
+nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)
+{
+  PRBool moreEvents = PR_FALSE;
+
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  PRBool eventProcessed = PR_FALSE;
+  NSString* currentMode = nil;
+
+  if (mTerminated)
+    return PR_FALSE;
+
+  PRBool wasRunningEventLoop = mRunningEventLoop;
+  mRunningEventLoop = aMayWait;
+  NSDate* waitUntil = nil;
+  if (aMayWait)
+    waitUntil = [NSDate distantFuture];
+
+  NSRunLoop* currentRunLoop = [NSRunLoop currentRunLoop];
+
+  return PR_FALSE;
+}
+
+// Returns PR_TRUE if Gecko events are currently being processed in its "main"
+// event loop (or one of its "main" event loops).  Returns PR_FALSE if Gecko
+// events are being processed in a "nested" event loop, or if we're not
+// running in any sort of Gecko event loop.  How we process native events in
+// ProcessNextNativeEvent() turns on our decision (and if we make the wrong
+// choice, the result may be a hang).
+//
+// We define the "main" event loop(s) as the place (or places) where Gecko
+// event processing "normally" takes place, and all other Gecko event loops
+// as "nested".  The "nested" event loops are normally processed while a call
+// from a "main" event loop is on the stack ... but not always.  For example,
+// the Venkman JavaScript debugger runs a "nested" event loop (in jsdService::
+// EnterNestedEventLoop()) whenever it breaks into the current script.  But
+// if this happens as the result of the user pressing a key combination, there
+// won't be any other Gecko event-processing call on the stack (e.g.
+// NS_ProcessNextEvent() or NS_ProcessPendingEvents()).  (In the current
+// nsAppShell implementation, what counts as the "main" event loop is what
+// nsBaseAppShell::NativeEventCallback() does to process Gecko events.  We
+// don't currently use nsBaseAppShell::Run().)
+PRBool
+nsAppShell::InGeckoMainEventLoop()
+{
+  return PR_FALSE;
+}
+
+// Run
+//
+// Overrides the base class's Run() method to call [NSApp run] (which spins
+// the native run loop until the application quits).  Since (unlike the base
+// class's Run() method) we don't process any Gecko events here, they need
+// to be processed elsewhere (in NativeEventCallback(), called from
+// ProcessGeckoEvents()).
+//
+// public
+NS_IMETHODIMP
+nsAppShell::Run(void)
+{
+  NS_ASSERTION(!mStarted, "nsAppShell::Run() called multiple times");
+  if (mStarted)
+    return NS_OK;
+
+  mStarted = PR_TRUE;
+  NS_OBJC_TRY_ABORT([NSApp run]);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsAppShell::Exit(void)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+  // This method is currently called more than once -- from (according to
+  // mento) an nsAppExitEvent dispatched by nsAppStartup::Quit() and from an
+  // XPCOM shutdown notification that nsBaseAppShell has registered to
+  // receive.  So we need to ensure that multiple calls won't break anything.
+  // But we should also complain about it (since it isn't quite kosher).
+  if (mTerminated) {
+    NS_WARNING("nsAppShell::Exit() called redundantly");
+    return NS_OK;
+  }
+
+  mTerminated = PR_TRUE;
+
+  delete gCocoaAppModalWindowList;
+  gCocoaAppModalWindowList = NULL;
+
+#ifndef NP_NO_CARBON
+  NS_RemovePluginKeyEventsHandler();
+#endif
+
+  // Quoting from Apple's doc on the [NSApplication stop:] method (from their
+  // doc on the NSApplication class):  "If this method is invoked during a
+  // modal event loop, it will break that loop but not the main event loop."
+  // nsAppShell::Exit() shouldn't be called from a modal event loop.  So if
+  // it is we complain about it (to users of debug builds) and call [NSApp
+  // stop:] one extra time.  (I'm not sure if modal event loops can be nested
+  // -- Apple's docs don't say one way or the other.  But the return value
+  // of [NSApp _isRunningModal] doesn't change immediately after a call to
+  // [NSApp stop:], so we have to assume that one extra call to [NSApp stop:]
+  // will do the job.)
+  BOOL cocoaModal = [NSApp _isRunningModal];
+  NS_ASSERTION(!cocoaModal,
+               "Don't call nsAppShell::Exit() from a modal event loop!");
+  if (cocoaModal)
+    [NSApp stop:nsnull];
+  [NSApp stop:nsnull];
+
+  // A call to Exit() just after a call to ScheduleNativeEventCallback()
+  // prevents the (normally) matching call to ProcessGeckoEvents() from
+  // happening.  If we've been called from ProcessGeckoEvents() (as usually
+  // happens), we take care of it there.  But if we have an unbalanced call
+  // to ScheduleNativeEventCallback() and ProcessGeckoEvents() isn't on the
+  // stack, we need to take care of the problem here.
+  if (!mNativeEventCallbackDepth && mNativeEventScheduledDepth) {
+    PRInt32 releaseCount = PR_AtomicSet(&mNativeEventScheduledDepth, 0);
+    while (releaseCount-- > 0)
+      NS_RELEASE_THIS();
+  }
+
+  return nsBaseAppShell::Exit();
+
+  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
+
+// OnProcessNextEvent
+//
+// This nsIThreadObserver method is called prior to processing an event.
+// Set up an autorelease pool that will service any autoreleased Cocoa
+// objects during this event.  This includes native events processed by
+// ProcessNextNativeEvent.  The autorelease pool will be popped by
+// AfterProcessNextEvent, it is important for these two methods to be
+// tightly coupled.
+//
+// public
+NS_IMETHODIMP
+nsAppShell::OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,
+                               PRUint32 aRecursionDepth)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+  mRecursionDepth = aRecursionDepth;
+
+  NS_ASSERTION(mAutoreleasePools,
+               "No stack on which to store autorelease pool");
+
+  NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
+  ::CFArrayAppendValue(mAutoreleasePools, pool);
+
+  return nsBaseAppShell::OnProcessNextEvent(aThread, aMayWait, aRecursionDepth);
+
+  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
+
+// AfterProcessNextEvent
+//
+// This nsIThreadObserver method is called after event processing is complete.
+// The Cocoa implementation cleans up the autorelease pool create by the
+// previous OnProcessNextEvent call.
+//
+// public
+NS_IMETHODIMP
+nsAppShell::AfterProcessNextEvent(nsIThreadInternal *aThread,
+                                  PRUint32 aRecursionDepth)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+  mRecursionDepth = aRecursionDepth;
+
+  CFIndex count = ::CFArrayGetCount(mAutoreleasePools);
+
+  NS_ASSERTION(mAutoreleasePools && count,
+               "Processed an event, but there's no autorelease pool?");
+
+  const NSAutoreleasePool* pool = static_cast<const NSAutoreleasePool*>
+    (::CFArrayGetValueAtIndex(mAutoreleasePools, count - 1));
+  ::CFArrayRemoveValueAtIndex(mAutoreleasePools, count - 1);
+  [pool release];
+
+  return nsBaseAppShell::AfterProcessNextEvent(aThread, aRecursionDepth);
+
+  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
+
+
+// AppShellDelegate implementation
+
+
+@implementation AppShellDelegate
+// initWithAppShell:
+//
+// Constructs the AppShellDelegate object
+- (id)initWithAppShell:(nsAppShell*)aAppShell
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
+
+  if ((self = [self init])) {
+    mAppShell = aAppShell;
+
+    [[NSNotificationCenter defaultCenter] addObserver:self
+                                             selector:@selector(applicationWillTerminate:)
+                                                 name:NSApplicationWillTerminateNotification
+                                               object:NSApp];
+    [[NSNotificationCenter defaultCenter] addObserver:self
+                                             selector:@selector(applicationDidBecomeActive:)
+                                                 name:NSApplicationDidBecomeActiveNotification
+                                               object:NSApp];
+    [[NSDistributedNotificationCenter defaultCenter] addObserver:self
+                                                        selector:@selector(beginMenuTracking:)
+                                                            name:@"com.apple.HIToolbox.beginMenuTrackingNotification"
+                                                          object:nil];
+  }
+
+  return self;
+
+  NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
+}
+
+- (void)dealloc
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  [[NSNotificationCenter defaultCenter] removeObserver:self];
+  [[NSDistributedNotificationCenter defaultCenter] removeObserver:self];
+  [super dealloc];
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+// applicationWillTerminate:
+//
+// Notify the nsAppShell that native event processing should be discontinued.
+- (void)applicationWillTerminate:(NSNotification*)aNotification
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  mAppShell->WillTerminate();
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+// applicationDidBecomeActive
+//
+// Make sure gLastModifierState is updated when we become active (since we
+// won't have received [ChildView flagsChanged:] messages while inactive).
+- (void)applicationDidBecomeActive:(NSNotification*)aNotification
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  // [NSEvent modifierFlags] is valid on every kind of event, so we don't need
+  // to worry about getting an NSInternalInconsistencyException here.
+  NSEvent* currentEvent = [NSApp currentEvent];
+  if (currentEvent) {
+    gLastModifierState = [currentEvent modifierFlags] & NSDeviceIndependentModifierFlagsMask;
+  }
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+// beginMenuTracking
+//
+// Roll up our context menu (if any) when some other app (or the OS) opens
+// any sort of menu.  But make sure we don't do this for notifications we
+// send ourselves (whose 'sender' will be @"org.mozilla.gecko.PopupWindow").
+- (void)beginMenuTracking:(NSNotification*)aNotification
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  NSString *sender = [aNotification object];
+  if (!sender || ![sender isEqualToString:@"org.mozilla.gecko.PopupWindow"]) {
+    if (gRollupListener && gRollupWidget)
+      gRollupListener->Rollup(nsnull, nsnull);
+  }
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+@end
+
+// We hook these methods in order to maintain a list of Cocoa app-modal
+// windows (and the "sessions" to which they correspond).  We need this in
+// order to deal with the consequences of a Cocoa app-modal dialog being
+// "interrupted" by a Gecko-modal dialog.  See nsCocoaAppModalWindowList::
+// CurrentSession() and nsAppShell::ProcessNextNativeEvent() above.
+@interface NSApplication (MethodSwizzling)
+- (NSModalSession)nsAppShell_NSApplication_beginModalSessionForWindow:(NSWindow *)aWindow;
+- (void)nsAppShell_NSApplication_endModalSession:(NSModalSession)aSession;
+@end
+
+@implementation NSApplication (MethodSwizzling)
+
+// Called if and only if a Cocoa app-modal session is beginning.  Always call
+// gCocoaAppModalWindowList->PushCocoa() here (if gCocoaAppModalWindowList is
+// non-nil).
+- (NSModalSession)nsAppShell_NSApplication_beginModalSessionForWindow:(NSWindow *)aWindow
+{
+  NSModalSession session =
+    [self nsAppShell_NSApplication_beginModalSessionForWindow:aWindow];
+  if (gCocoaAppModalWindowList)
+    gCocoaAppModalWindowList->PushCocoa(aWindow, session);
+  return session;
+}
+
+// Called to end any Cocoa modal session (app-modal or otherwise).  Only call
+// gCocoaAppModalWindowList->PopCocoa() when an app-modal session is ending
+// (and when gCocoaAppModalWindowList is non-nil).
+- (void)nsAppShell_NSApplication_endModalSession:(NSModalSession)aSession
+{
+  BOOL wasRunningAppModal = [NSApp _isRunningAppModal];
+  NSWindow *prevAppModalWindow = [NSApp modalWindow];
+  [self nsAppShell_NSApplication_endModalSession:aSession];
+  if (gCocoaAppModalWindowList &&
+      wasRunningAppModal && (prevAppModalWindow != [NSApp modalWindow]))
+    gCocoaAppModalWindowList->PopCocoa(prevAppModalWindow, aSession);
+}
+
+@end
+
+@interface NSObject (PDEPluginCallbackMethodSwizzling)
+- (id)nsAppShell_PDEPluginCallback_initWithPrintWindowController:(id)controller;
+- (void)nsAppShell_PDEPluginCallback_dealloc;
+@end
+
+@implementation NSObject (PDEPluginCallbackMethodSwizzling)
+
+// On Leopard, the PDEPluginCallback class in Apple's PrintCocoaUI module
+// fails to retain and release its PMPrintWindowController object.  This
+// causes the PMPrintWindowController to sometimes be deleted prematurely,
+// leading to crashes on attempts to access it.  One example is bug 396680,
+// caused by attempting to call a deleted PMPrintWindowController object's
+// printSettings method.  We work around the problem by hooking the
+// appropriate methods and retaining and releasing the object ourselves.
+// PrintCocoaUI.bundle is a "plugin" of the Carbon framework's Print
+// framework.
+
+- (id)nsAppShell_PDEPluginCallback_initWithPrintWindowController:(id)controller
+{
+  return [self nsAppShell_PDEPluginCallback_initWithPrintWindowController:[controller retain]];
+}
+
+- (void)nsAppShell_PDEPluginCallback_dealloc
+{
+  // Since the PDEPluginCallback class is undocumented (and the OS header
+  // files have no definition for it), we need to use low-level methods to
+  // access its _printWindowController variable.  (object_getInstanceVariable()
+  // is also available in Objective-C 2.0, so this code is 64-bit safe.)
+  id _printWindowController = nil;
+  object_getInstanceVariable(self, "_printWindowController",
+                             (void **) &_printWindowController);
+  [_printWindowController release];
+  [self nsAppShell_PDEPluginCallback_dealloc];
+}
+
+@end
diff --git a/widget/src/uikit/nsWidgetFactory.mm b/widget/src/uikit/nsWidgetFactory.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsWidgetFactory.mm
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIFactory.h"
+#include "nsISupports.h"
+#include "nsIComponentManager.h"
+#include "nsIGenericFactory.h"
+
+#include "nsWidgetsCID.h"
+
+#include "nsAppShell.h"
+#include "nsAppShellSingleton.h"
+
+static const nsModuleComponentInfo gComponents[] =
+{
+  { "AppShell",
+    NS_APPSHELL_CID,
+    "@mozilla.org/widget/appshell/mac;1",
+    nsAppShellConstructor },
+};
+
+NS_IMPL_NSGETMODULE_WITH_CTOR_DTOR(nsWidgetUIKitModule, gComponents,
+                                   nsAppShellInit, nsAppShellShutdown)
