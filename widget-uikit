# HG changeset patch
# User Ted Mielczarek <ted.mielczarek@gmail.com>
# Date 1273581972 14400
# Node ID c503bc0ef58848a00630bd69fd17113bf0413f0e
# Parent  a73cc81d9d52ab88a607ec15e64753f975fa818c
UIKit widget implementation

diff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk
+++ b/toolkit/library/libxul-config.mk
@@ -313,6 +313,9 @@
 ifeq (qt,$(MOZ_WIDGET_TOOLKIT))
 COMPONENT_LIBS += widget_qt
 endif
+ifeq (uikit,$(MOZ_WIDGET_TOOLKIT))
+COMPONENT_LIBS += widget_uikit
+endif
 
 ifdef MOZ_ENABLE_PHOTON
 COMPONENT_LIBS += widget_photon
diff --git a/widget/src/Makefile.in b/widget/src/Makefile.in
--- a/widget/src/Makefile.in
+++ b/widget/src/Makefile.in
@@ -46,7 +46,7 @@
 
 DIRS		= xpwidgets
 
-ifneq (,$(filter beos os2 cocoa qt,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter beos os2 cocoa qt uikit,$(MOZ_WIDGET_TOOLKIT)))
 DIRS		+= $(MOZ_WIDGET_TOOLKIT)
 endif
 
diff --git a/widget/src/uikit/Makefile.in b/widget/src/uikit/Makefile.in
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/Makefile.in
@@ -0,0 +1,80 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org Code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= widget
+LIBRARY_NAME	= widget_uikit
+EXPORT_LIBRARY	= 1
+IS_COMPONENT	= 1
+MODULE_NAME	= nsWidgetUIKitModule
+XPIDL_MODULE	= widget_uikit
+GRE_MODULE	= 1
+LIBXUL_LIBRARY = 1
+
+
+CMMSRCS = \
+  nsAppShell.mm \
+  nsLookAndFeel.mm \
+  nsScreenManager.mm \
+  nsToolkit.mm \
+  nsWidgetFactory.mm \
+  nsWindow.mm \
+  $(NULL)
+
+SHARED_LIBRARY_LIBS = ../xpwidgets/libxpwidgets_s.a
+
+EXTRA_DSO_LDOPTS += \
+  $(MOZ_UNICHARUTIL_LIBS) \
+  $(TK_LIBS) \
+  $(call EXPAND_LIBNAME_PATH,gkgfx,$(DEPTH)/gfx/src) \
+  $(MOZ_COMPONENT_LIBS) \
+  -lthebes \
+  $(QCMS_LIBS) \
+  $(NULL)
+
+include $(topsrcdir)/config/rules.mk
+
+LOCAL_INCLUDES	= \
+  $(TK_CFLAGS) \
+  -I$(srcdir)/../xpwidgets \
+  $(NULL)
diff --git a/widget/src/uikit/nsAppShell.h b/widget/src/uikit/nsAppShell.h
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsAppShell.h
@@ -0,0 +1,86 @@
+/* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is a Cocoa widget run loop and event implementation.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Runs the main native UIKit run loop, interrupting it as needed to process
+ * Gecko events.  
+ */
+
+#ifndef nsAppShell_h_
+#define nsAppShell_h_
+
+#include "nsBaseAppShell.h"
+#include "nsTArray.h"
+
+#include <Foundation/NSAutoreleasePool.h>
+#include <CoreFoundation/CFRunLoop.h>
+
+@class AppShellDelegate;
+
+class nsAppShell : public nsBaseAppShell
+{
+public:
+  NS_IMETHOD ResumeNative(void);
+	
+  nsAppShell();
+
+  nsresult Init();
+
+  NS_IMETHOD Run(void);
+  NS_IMETHOD Exit(void);
+  // Called by the application delegate
+  void WillTerminate(void);
+
+  static nsAppShell* gAppShell;
+
+protected:
+  virtual ~nsAppShell();
+
+  static void ProcessGeckoEvents(void* aInfo);
+  virtual void ScheduleNativeEventCallback();
+  virtual PRBool ProcessNextNativeEvent(PRBool aMayWait);
+
+  NSAutoreleasePool* mAutoreleasePool;
+  AppShellDelegate*  mDelegate;
+  CFRunLoopRef       mCFRunLoop;
+  CFRunLoopSourceRef mCFRunLoopSource;
+
+  PRPackedBool       mTerminated;
+  PRPackedBool       mNotifiedWillTerminate;
+};
+
+#endif // nsAppShell_h_
diff --git a/widget/src/uikit/nsAppShell.mm b/widget/src/uikit/nsAppShell.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsAppShell.mm
@@ -0,0 +1,252 @@
+/* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is a Cocoa widget run loop and event implementation.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <UIKit/UIApplication.h>
+
+#include "nsAppShell.h"
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsString.h"
+#include "nsIRollupListener.h"
+#include "nsIWidget.h"
+#include "nsThreadUtils.h"
+#include "nsIWindowMediator.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIInterfaceRequestor.h"
+#include "nsIWebBrowserChrome.h"
+
+nsAppShell *nsAppShell::gAppShell = NULL;
+
+// AppShellDelegate
+//
+// Acts as a delegate for the UIApplication
+
+@interface AppShellDelegate : NSObject <UIApplicationDelegate> {
+}
+@end
+
+@implementation AppShellDelegate
+- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
+{
+  return YES;
+}
+
+- (void)applicationWillTerminate:(UIApplication *)application
+{
+  nsAppShell::gAppShell->WillTerminate();
+}
+
+- (void)applicationDidBecomeActive:(UIApplication *)application
+{
+}
+
+- (void)applicationWillResignActive:(UIApplication *)application
+{
+}
+
+- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application
+{
+}
+@end
+
+// nsAppShell implementation
+
+NS_IMETHODIMP
+nsAppShell::ResumeNative(void)
+{
+  return nsBaseAppShell::ResumeNative();
+}
+
+nsAppShell::nsAppShell()
+  : mAutoreleasePool(NULL),
+    mDelegate(NULL),
+    mCFRunLoop(NULL),
+    mCFRunLoopSource(NULL),
+    mTerminated(PR_FALSE),
+    mNotifiedWillTerminate(PR_FALSE)
+{
+  gAppShell = this;
+}
+
+nsAppShell::~nsAppShell()
+{
+  if (mAutoreleasePool) {
+    [mAutoreleasePool release];
+    mAutoreleasePool = NULL;
+  }
+
+  if (mCFRunLoop) {
+    if (mCFRunLoopSource) {
+      ::CFRunLoopRemoveSource(mCFRunLoop, mCFRunLoopSource,
+                              kCFRunLoopCommonModes);
+      ::CFRelease(mCFRunLoopSource);
+    }
+    ::CFRelease(mCFRunLoop);
+  }
+
+  gAppShell = NULL;
+}
+
+// Init
+//
+// public
+nsresult
+nsAppShell::Init()
+{
+  mAutoreleasePool = [[NSAutoreleasePool alloc] init];
+
+  // Add a CFRunLoopSource to the main native run loop.  The source is
+  // responsible for interrupting the run loop when Gecko events are ready.
+
+  mCFRunLoop = [[NSRunLoop currentRunLoop] getCFRunLoop];
+  NS_ENSURE_STATE(mCFRunLoop);
+  ::CFRetain(mCFRunLoop);
+
+  CFRunLoopSourceContext context;
+  bzero(&context, sizeof(context));
+  // context.version = 0;
+  context.info = this;
+  context.perform = ProcessGeckoEvents;
+  
+  mCFRunLoopSource = ::CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);
+  NS_ENSURE_STATE(mCFRunLoopSource);
+
+  ::CFRunLoopAddSource(mCFRunLoop, mCFRunLoopSource, kCFRunLoopCommonModes);
+
+  return nsBaseAppShell::Init();
+}
+
+// ProcessGeckoEvents
+//
+// The "perform" target of mCFRunLoop, called when mCFRunLoopSource is
+// signalled from ScheduleNativeEventCallback.
+//
+// protected static
+void
+nsAppShell::ProcessGeckoEvents(void* aInfo)
+{
+  nsAppShell* self = static_cast<nsAppShell*> (aInfo);
+  self->NativeEventCallback();
+  self->Release();
+}
+
+// WillTerminate
+//
+// public
+void
+nsAppShell::WillTerminate()
+{
+  mNotifiedWillTerminate = PR_TRUE;
+  if (mTerminated)
+    return;
+  mTerminated = PR_TRUE;
+  // We won't get another chance to process events
+  NS_ProcessPendingEvents(NS_GetCurrentThread());
+  
+  // Unless we call nsBaseAppShell::Exit() here, it might not get called
+  // at all.
+  nsBaseAppShell::Exit();
+}
+
+// ScheduleNativeEventCallback
+//
+// protected virtual
+void
+nsAppShell::ScheduleNativeEventCallback()
+{
+  if (mTerminated)
+    return;
+
+  NS_ADDREF_THIS();
+
+  // This will invoke ProcessGeckoEvents on the main thread.
+  ::CFRunLoopSourceSignal(mCFRunLoopSource);
+  ::CFRunLoopWakeUp(mCFRunLoop);
+}
+
+// ProcessNextNativeEvent
+//
+// protected virtual
+PRBool
+nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)
+{
+  if (mTerminated)
+    return PR_FALSE;
+
+  NSString* currentMode = nil;
+  NSDate* waitUntil = nil;
+  if (aMayWait)
+    waitUntil = [NSDate distantFuture];
+  NSRunLoop* currentRunLoop = [NSRunLoop currentRunLoop];
+
+  BOOL eventProcessed = NO;
+  do {
+    currentMode = [currentRunLoop currentMode];
+    if (!currentMode)
+      currentMode = NSDefaultRunLoopMode;
+
+    if (aMayWait)
+      eventProcessed = [currentRunLoop runMode:currentMode beforeDate:waitUntil];
+    else
+      [currentRunLoop acceptInputForMode:currentMode beforeDate:waitUntil];
+  } while(eventProcessed && aMayWait);
+
+  return PR_FALSE;
+}
+
+// Run
+//
+// public
+NS_IMETHODIMP
+nsAppShell::Run(void)
+{
+  char *argv[1] = {"app"};
+  UIApplicationMain(1, argv, nil, @"AppShellDelegate");
+  // UIApplicationMain doesn't exit. :-(
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsAppShell::Exit(void)
+{
+  if (mTerminated)
+    return NS_OK;
+
+  mTerminated = PR_TRUE;
+  return nsBaseAppShell::Exit();
+}
diff --git a/widget/src/uikit/nsLookAndFeel.h b/widget/src/uikit/nsLookAndFeel.h
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsLookAndFeel.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ted Mielczarek <ted.mielczarek@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef __nsLookAndFeel
+#define __nsLookAndFeel
+
+#include "nsXPLookAndFeel.h"
+
+class nsLookAndFeel: public nsXPLookAndFeel
+{
+public:
+  nsLookAndFeel();
+  virtual ~nsLookAndFeel();
+
+  nsresult NativeGetColor(const nsColorID aID, nscolor &aColor);
+  NS_IMETHOD GetMetric(const nsMetricID aID, PRInt32 & aMetric);
+  NS_IMETHOD GetMetric(const nsMetricFloatID aID, float & aMetric);
+};
+
+#endif
diff --git a/widget/src/uikit/nsLookAndFeel.mm b/widget/src/uikit/nsLookAndFeel.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsLookAndFeel.mm
@@ -0,0 +1,489 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ted Mielczarek <ted.mielczarek@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <UIKit/UIColor.h>
+#import <UIKit/UIInterface.h>
+
+#include "nsLookAndFeel.h"
+
+nsLookAndFeel::nsLookAndFeel()
+    : nsXPLookAndFeel()
+{
+}
+
+nsLookAndFeel::~nsLookAndFeel()
+{
+}
+
+static nscolor GetColorFromUIColor(UIColor* aColor)
+{
+    CGColorRef cgColor = [aColor CGColor];
+    CGColorSpaceModel model = CGColorSpaceGetModel(CGColorGetColorSpace(cgColor));
+    const CGFloat* components = CGColorGetComponents(cgColor);
+    if (model == kCGColorSpaceModelRGB) {
+        return NS_RGB((unsigned int)(components[0] * 255.0),
+                      (unsigned int)(components[1] * 255.0),
+                      (unsigned int)(components[2] * 255.0));
+    }
+    else if (model == kCGColorSpaceModelMonochrome) {
+        unsigned int val = (unsigned int)(components[0] * 255.0);
+        return NS_RGBA(val, val, val,
+                       (unsigned int)(components[1] * 255.0));
+    }
+    NS_NOTREACHED("Unhandled color space!");
+    return 0;
+}
+
+nsresult
+nsLookAndFeel::NativeGetColor(const nsColorID aID, nscolor &aColor)
+{
+  nsresult res = NS_OK;
+  
+  switch (aID) {
+    case eColor_WindowBackground:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor_WindowForeground:
+      aColor = NS_RGB(0x00,0x00,0x00);        
+      break;
+    case eColor_WidgetBackground:
+      aColor = NS_RGB(0xdd,0xdd,0xdd);
+      break;
+    case eColor_WidgetForeground:
+      aColor = NS_RGB(0x00,0x00,0x00);        
+      break;
+    case eColor_WidgetSelectBackground:
+      aColor = NS_RGB(0x80,0x80,0x80);
+      break;
+    case eColor_WidgetSelectForeground:
+      aColor = NS_RGB(0x00,0x00,0x80);
+      break;
+    case eColor_Widget3DHighlight:
+      aColor = NS_RGB(0xa0,0xa0,0xa0);
+      break;
+    case eColor_Widget3DShadow:
+      aColor = NS_RGB(0x40,0x40,0x40);
+      break;
+    case eColor_TextBackground:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor_TextForeground:
+      aColor = NS_RGB(0x00,0x00,0x00);
+      break;
+    case eColor_TextSelectBackground:
+    case eColor_highlight: // CSS2 color
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor__moz_menuhover:
+      aColor = NS_RGB(0xee,0xee,0xee);
+      break;      
+    case eColor_TextSelectForeground:
+    case eColor_highlighttext:  // CSS2 color
+    case eColor__moz_menuhovertext:
+      GetColor(eColor_TextSelectBackground, aColor);
+      if (aColor == 0x000000)
+        aColor = NS_RGB(0xff,0xff,0xff);
+      else
+        aColor = NS_DONT_CHANGE_COLOR;
+      break;
+    case eColor_IMESelectedRawTextBackground:
+    case eColor_IMESelectedConvertedTextBackground:
+    case eColor_IMERawInputBackground:
+    case eColor_IMEConvertedTextBackground:
+      aColor = NS_TRANSPARENT;
+      break;
+    case eColor_IMESelectedRawTextForeground:
+    case eColor_IMESelectedConvertedTextForeground:
+    case eColor_IMERawInputForeground:
+    case eColor_IMEConvertedTextForeground:
+      aColor = NS_SAME_AS_FOREGROUND_COLOR;
+      break;
+    case eColor_IMERawInputUnderline:
+    case eColor_IMEConvertedTextUnderline:
+      aColor = NS_40PERCENT_FOREGROUND_COLOR;
+      break;
+    case eColor_IMESelectedRawTextUnderline:
+    case eColor_IMESelectedConvertedTextUnderline:
+      aColor = NS_SAME_AS_FOREGROUND_COLOR;
+      break;
+    case eColor_SpellCheckerUnderline:
+      aColor = NS_RGB(0xff, 0, 0);
+      break;
+
+    //
+    // css2 system colors http://www.w3.org/TR/REC-CSS2/ui.html#system-colors
+    //
+    case eColor_buttontext:
+    case eColor__moz_buttonhovertext:
+    case eColor_captiontext:
+    case eColor_menutext:
+    case eColor_infotext:
+    case eColor__moz_menubartext:
+    case eColor_windowtext:
+      aColor = GetColorFromUIColor([UIColor darkTextColor]);
+      break;
+    case eColor_activecaption:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor_activeborder:
+      aColor = NS_RGB(0x00,0x00,0x00);
+      break;
+     case eColor_appworkspace:
+      aColor = NS_RGB(0xFF,0xFF,0xFF);
+      break;
+    case eColor_background:
+      aColor = NS_RGB(0x63,0x63,0xCE);
+      break;
+    case eColor_buttonface:
+    case eColor__moz_buttonhoverface:
+      aColor = NS_RGB(0xF0,0xF0,0xF0);
+      break;
+    case eColor_buttonhighlight:
+      aColor = NS_RGB(0xFF,0xFF,0xFF);
+      break;
+    case eColor_buttonshadow:
+      aColor = NS_RGB(0xDC,0xDC,0xDC);
+      break;
+    case eColor_graytext:
+      aColor = NS_RGB(0x44,0x44,0x44);
+      break;
+    case eColor_inactiveborder:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor_inactivecaption:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor_inactivecaptiontext:
+      aColor = NS_RGB(0x45,0x45,0x45);
+      break;
+    case eColor_scrollbar:
+      aColor = NS_RGB(0,0,0); //XXX
+      break;
+    case eColor_threeddarkshadow:
+      aColor = NS_RGB(0xDC,0xDC,0xDC);
+      break;
+    case eColor_threedshadow:
+      aColor = NS_RGB(0xE0,0xE0,0xE0);
+      break;
+    case eColor_threedface:
+      aColor = NS_RGB(0xF0,0xF0,0xF0);
+      break;
+    case eColor_threedhighlight:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor_threedlightshadow:
+      aColor = NS_RGB(0xDA,0xDA,0xDA);
+      break;
+    case eColor_menu:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor_infobackground:
+      aColor = NS_RGB(0xFF,0xFF,0xC7);
+      break;
+    case eColor_windowframe:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor_window:
+    case eColor__moz_field:
+    case eColor__moz_combobox:
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor__moz_fieldtext:
+    case eColor__moz_comboboxtext:
+      aColor = GetColorFromUIColor([UIColor darkTextColor]);
+      break;
+    case eColor__moz_dialog:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor__moz_dialogtext:
+    case eColor__moz_cellhighlighttext:
+    case eColor__moz_html_cellhighlighttext:
+      aColor = GetColorFromUIColor([UIColor darkTextColor]);
+      break;
+    case eColor__moz_dragtargetzone:
+    case eColor__moz_mac_chrome_active:
+    case eColor__moz_mac_chrome_inactive:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor__moz_mac_focusring:
+      aColor = NS_RGB(0x3F,0x98,0xDD);
+      break;
+    case eColor__moz_mac_menushadow:
+      aColor = NS_RGB(0xA3,0xA3,0xA3);
+      break;          
+    case eColor__moz_mac_menutextdisable:
+      aColor = NS_RGB(0x88,0x88,0x88);
+      break;      
+    case eColor__moz_mac_menutextselect:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;      
+    case eColor__moz_mac_disabledtoolbartext:
+      aColor = NS_RGB(0x3F,0x3F,0x3F);
+      break;
+    case eColor__moz_mac_menuselect:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor__moz_buttondefault:
+      aColor = NS_RGB(0xDC,0xDC,0xDC);
+      break;
+    case eColor__moz_mac_alternateprimaryhighlight:
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor__moz_cellhighlight:
+    case eColor__moz_html_cellhighlight:
+    case eColor__moz_mac_secondaryhighlight:
+      // For inactive list selection
+      aColor = NS_RGB(0xaa,0xaa,0xaa);
+      break;
+    case eColor__moz_eventreerow:
+      // Background color of even list rows.
+      aColor = NS_RGB(0xff,0xff,0xff);
+      break;
+    case eColor__moz_oddtreerow:
+      // Background color of odd list rows.
+      aColor = NS_TRANSPARENT;
+      break;
+    case eColor__moz_nativehyperlinktext:
+      // There appears to be no available system defined color. HARDCODING to the appropriate color.
+      aColor = NS_RGB(0x14,0x4F,0xAE);
+      break;
+    default:
+      NS_WARNING("Someone asked nsILookAndFeel for a color I don't know about");
+      aColor = NS_RGB(0xff,0xff,0xff);
+      res = NS_ERROR_FAILURE;
+      break;
+    }
+  
+  return res;
+}
+
+NS_IMETHODIMP
+nsLookAndFeel::GetMetric(const nsMetricID aID, PRInt32 &aMetric)
+{
+  nsresult res = nsXPLookAndFeel::GetMetric(aID, aMetric);
+  if (NS_SUCCEEDED(res))
+    return res;
+  res = NS_OK;
+  
+  switch (aID) {
+    case eMetric_WindowTitleHeight:
+      aMetric = 0;
+      break;
+    case eMetric_WindowBorderWidth:
+      aMetric = 4;
+      break;
+    case eMetric_WindowBorderHeight:
+      aMetric = 4;
+      break;
+    case eMetric_Widget3DBorder:
+      aMetric = 4;
+      break;
+    case eMetric_TextFieldHeight:
+      aMetric = 16;
+      break;
+    case eMetric_TextFieldBorder:
+      aMetric = 2;
+      break;
+    case eMetric_ButtonHorizontalInsidePaddingNavQuirks:
+      aMetric = 20;
+      break;
+    case eMetric_ButtonHorizontalInsidePaddingOffsetNavQuirks:
+      aMetric = 0;
+      break;
+    case eMetric_CheckboxSize:
+      aMetric = 14;
+      break;
+    case eMetric_RadioboxSize:
+      aMetric = 14;
+      break;
+    case eMetric_TextHorizontalInsideMinimumPadding:
+      aMetric = 4;
+      break;
+    case eMetric_TextVerticalInsidePadding:
+      aMetric = 4;
+      break;
+    case eMetric_TextShouldUseVerticalInsidePadding:
+      aMetric = 1;
+      break;
+    case eMetric_TextShouldUseHorizontalInsideMinimumPadding:
+      aMetric = 1;
+      break;
+    case eMetric_ListShouldUseHorizontalInsideMinimumPadding:
+      aMetric = 0;
+      break;
+    case eMetric_ListHorizontalInsideMinimumPadding:
+      aMetric = 4;
+      break;
+    case eMetric_ListShouldUseVerticalInsidePadding:
+      aMetric = 1;
+      break;
+    case eMetric_ListVerticalInsidePadding:
+      aMetric = 3;
+      break;
+    case eMetric_CaretBlinkTime:
+      aMetric = 567;
+      break;
+    case eMetric_CaretWidth:
+      aMetric = 1;
+      break;
+    case eMetric_ShowCaretDuringSelection:
+      aMetric = 0;
+      break;
+    case eMetric_SelectTextfieldsOnKeyFocus:
+      // Select textfield content when focused by kbd
+      // used by nsEventStateManager::sTextfieldSelectModel
+      aMetric = 1;
+      break;
+    case eMetric_SubmenuDelay:
+      aMetric = 200;
+      break;
+    case eMetric_MenusCanOverlapOSBar:
+      // xul popups are not allowed to overlap the menubar.
+      aMetric = 0;
+      break;
+    case eMetric_SkipNavigatingDisabledMenuItem:
+      aMetric = 1;
+      break;
+    case eMetric_DragThresholdX:
+    case eMetric_DragThresholdY:
+      aMetric = 4;
+      break;
+    case eMetric_ScrollArrowStyle:
+      aMetric = eMetric_ScrollArrowStyleSingle;
+      break;
+    case eMetric_ScrollSliderStyle:
+      aMetric = eMetric_ScrollThumbStyleProportional;
+      break;
+    case eMetric_TreeOpenDelay:
+      aMetric = 1000;
+      break;
+    case eMetric_TreeCloseDelay:
+      aMetric = 1000;
+      break;
+    case eMetric_TreeLazyScrollDelay:
+      aMetric = 150;
+      break;
+    case eMetric_TreeScrollDelay:
+      aMetric = 100;
+      break;
+    case eMetric_TreeScrollLinesMax:
+      aMetric = 3;
+      break;
+    case eMetric_DWMCompositor:
+    case eMetric_WindowsClassic:
+    case eMetric_WindowsDefaultTheme:
+    case eMetric_TouchEnabled:
+    case eMetric_MaemoClassic:
+      aMetric = 0;
+      res = NS_ERROR_NOT_IMPLEMENTED;
+      break;
+    case eMetric_MacGraphiteTheme:
+      aMetric = 0;
+      break;
+    case eMetric_TabFocusModel:
+      aMetric = 1;    // default to just textboxes
+      break;
+    case eMetric_ScrollToClick:
+      aMetric = 0;
+      break;
+    case eMetric_ChosenMenuItemsShouldBlink:
+      aMetric = 1;
+      break;
+    case eMetric_IMERawInputUnderlineStyle:
+    case eMetric_IMEConvertedTextUnderlineStyle:
+    case eMetric_IMESelectedRawTextUnderlineStyle:
+    case eMetric_IMESelectedConvertedTextUnderline:
+      aMetric = NS_UNDERLINE_STYLE_SOLID;
+      break;
+    case eMetric_SpellCheckerUnderlineStyle:
+      aMetric = NS_UNDERLINE_STYLE_DOTTED;
+      break;
+    default:
+      aMetric = 0;
+      res = NS_ERROR_FAILURE;
+  }
+  return res;
+}
+
+NS_IMETHODIMP
+nsLookAndFeel::GetMetric(const nsMetricFloatID aID,
+                         float &aMetric)
+{
+  nsresult res = nsXPLookAndFeel::GetMetric(aID, aMetric);
+  if (NS_SUCCEEDED(res))
+    return res;
+  res = NS_OK;
+  
+  switch (aID) {
+    case eMetricFloat_TextFieldVerticalInsidePadding:
+      aMetric = 0.25f;
+      break;
+    case eMetricFloat_TextFieldHorizontalInsidePadding:
+      aMetric = 0.95f;
+      break;
+    case eMetricFloat_TextAreaVerticalInsidePadding:
+      aMetric = 0.40f;
+      break;
+    case eMetricFloat_TextAreaHorizontalInsidePadding:
+      aMetric = 0.40f;
+      break;
+    case eMetricFloat_ListVerticalInsidePadding:
+      aMetric = 0.08f;
+      break;
+    case eMetricFloat_ListHorizontalInsidePadding:
+      aMetric = 0.40f;
+      break;
+    case eMetricFloat_ButtonVerticalInsidePadding:
+      aMetric = 0.5f;
+      break;
+    case eMetricFloat_ButtonHorizontalInsidePadding:
+      aMetric = 0.5f;
+      break;
+    case eMetricFloat_IMEUnderlineRelativeSize:
+      aMetric = 2.0f;
+      break;
+    case eMetricFloat_SpellCheckerUnderlineRelativeSize:
+      aMetric = 2.0f;
+      break;
+    default:
+      aMetric = -1.0;
+      res = NS_ERROR_FAILURE;
+  }
+
+  return res;
+}
diff --git a/widget/src/uikit/nsScreenManager.h b/widget/src/uikit/nsScreenManager.h
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsScreenManager.h
@@ -0,0 +1,77 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsScreenManager_h_
+#define nsScreenManager_h_
+
+#include "nsCOMPtr.h"
+#include "nsIScreen.h"
+#include "nsIScreenManager.h"
+
+#include "gfxContext.h"
+#include "nsRect.h"
+
+class nsUIKitScreen : public nsIScreen
+{
+public:
+    nsUIKitScreen (void* screen) {}
+    ~nsUIKitScreen () {}
+
+    NS_DECL_ISUPPORTS
+
+    NS_DECL_NSISCREEN
+};
+
+class nsScreenManager : public nsIScreenManager
+{
+public:
+    nsScreenManager ();
+    ~nsScreenManager () {}
+
+    NS_DECL_ISUPPORTS
+
+    NS_DECL_NSISCREENMANAGER
+
+    static nsIntRect GetBounds();
+
+private:
+    //TODO: support >1 screen, iPad supports external displays
+    nsCOMPtr<nsIScreen> mScreen;
+};
+
+#endif // nsScreenManager_h_
diff --git a/widget/src/uikit/nsScreenManager.mm b/widget/src/uikit/nsScreenManager.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsScreenManager.mm
@@ -0,0 +1,147 @@
+/* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *    Ted Mielczarek <ted.mielczarek@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <UIKit/UIScreen.h>
+
+#include "gfxPoint.h"
+#include "nsScreenManager.h"
+
+static nsIntRect gScreenBounds;
+
+NS_IMPL_ISUPPORTS1(nsUIKitScreen, nsIScreen)
+
+NS_IMETHODIMP
+nsUIKitScreen::GetRect(PRInt32 *outLeft, PRInt32 *outTop, PRInt32 *outWidth, PRInt32 *outHeight)
+{
+  CGRect rect = [[UIScreen mainScreen] bounds];
+
+  *outLeft = rect.origin.x;
+  *outTop = rect.origin.y;
+  *outWidth = rect.size.width;
+  *outHeight = rect.size.height;
+
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsUIKitScreen::GetAvailRect(PRInt32 *outLeft, PRInt32 *outTop, PRInt32 *outWidth, PRInt32 *outHeight)
+{
+  CGRect rect = [[UIScreen mainScreen] applicationFrame];
+
+  *outLeft = rect.origin.x;
+  *outTop = rect.origin.y;
+  *outWidth = rect.size.width;
+  *outHeight = rect.size.height;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsUIKitScreen::GetPixelDepth(PRInt32 *aPixelDepth)
+{
+  // XXX: this probably isn't right, but who knows?
+  *aPixelDepth = 24;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsUIKitScreen::GetColorDepth(PRInt32 *aColorDepth)
+{
+  return GetPixelDepth(aColorDepth);
+}
+
+NS_IMPL_ISUPPORTS1(nsScreenManager, nsIScreenManager)
+
+nsScreenManager::nsScreenManager()
+: mScreen(new nsUIKitScreen(nsnull))
+{
+}
+
+nsIntRect
+nsScreenManager::GetBounds()
+{
+    //XXX: this doesn't work right if your app hasn't finished launching.
+    // the status bar isn't there yet, so you get the full screen
+    CGRect rect = [[UIScreen mainScreen] applicationFrame];
+    gScreenBounds.x = rect.origin.x;
+    gScreenBounds.y = rect.origin.y;
+    gScreenBounds.width = rect.size.width;
+    gScreenBounds.height = rect.size.height;
+    if (rect.size.height == [[UIScreen mainScreen] bounds].size.height) {
+        // try to subtract out the status bar frame
+        // screw you UIKit
+        gScreenBounds.y += 20;
+        gScreenBounds.height -= 20;
+    }
+    printf("nsScreenManager::GetBounds: %d %d %d %d\n",
+           gScreenBounds.x, gScreenBounds.y, gScreenBounds.width, gScreenBounds.height);
+    return gScreenBounds;
+}
+
+NS_IMETHODIMP
+nsScreenManager::GetPrimaryScreen(nsIScreen **outScreen)
+{
+  NS_IF_ADDREF(*outScreen = mScreen.get());
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScreenManager::ScreenForRect(PRInt32 inLeft,
+                               PRInt32 inTop,
+                               PRInt32 inWidth,
+                               PRInt32 inHeight,
+                               nsIScreen **outScreen)
+{
+  return GetPrimaryScreen(outScreen);
+}
+
+NS_IMETHODIMP
+nsScreenManager::ScreenForNativeWidget(void *aWidget, nsIScreen **outScreen)
+{
+  return GetPrimaryScreen(outScreen);
+}
+
+NS_IMETHODIMP
+nsScreenManager::GetNumberOfScreens(PRUint32 *aNumberOfScreens)
+{
+  //TODO: support multiple screens
+  *aNumberOfScreens = 1;
+  return NS_OK;
+}
+
diff --git a/widget/src/uikit/nsToolkit.h b/widget/src/uikit/nsToolkit.h
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsToolkit.h
@@ -0,0 +1,59 @@
+/* -*- Mode: c++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// Just a copy of the Android/WebOS stub nsToolkit
+
+#ifndef nsToolkit_h__
+#define nsToolkit_h__
+
+#include <nsIToolkit.h>
+
+class nsToolkit :
+    public nsIToolkit
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    // nsIToolkit
+    NS_IMETHOD		Init(PRThread *aThread);
+
+    nsToolkit();
+    virtual ~nsToolkit();
+};
+
+#endif /* nsToolkit_h__ */
diff --git a/widget/src/uikit/nsToolkit.mm b/widget/src/uikit/nsToolkit.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsToolkit.mm
@@ -0,0 +1,98 @@
+/* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// Just a copy of the Android/WebOS stub nsToolkit
+
+#include "nsToolkit.h"
+#include "nsGUIEvent.h"
+#include "nsWidgetAtoms.h"
+
+NS_IMPL_ISUPPORTS1(nsToolkit, nsIToolkit)
+
+// why do we have this?
+static PRUintn gToolkitTLSIndex = 0;
+
+nsToolkit::nsToolkit()
+{
+}
+
+nsToolkit::~nsToolkit()
+{
+    PR_SetThreadPrivate(gToolkitTLSIndex, nsnull);
+}
+
+NS_IMETHODIMP
+nsToolkit::Init(PRThread *aThread)
+{
+    nsWidgetAtoms::RegisterAtoms();
+    return NS_OK;
+}
+
+NS_METHOD
+NS_GetCurrentToolkit(nsIToolkit* *aResult)
+{
+    nsCOMPtr<nsIToolkit> toolkit = nsnull;
+    nsresult rv = NS_OK;
+    PRStatus status;
+
+    if (gToolkitTLSIndex == 0) {
+        status = PR_NewThreadPrivateIndex(&gToolkitTLSIndex, NULL);
+        if (PR_FAILURE == status)
+            rv = NS_ERROR_FAILURE;
+    }
+
+    if (NS_FAILED(rv))
+        return rv;
+
+    toolkit = (nsIToolkit*) PR_GetThreadPrivate(gToolkitTLSIndex);
+    if (!toolkit) {
+        toolkit = new nsToolkit();
+
+        if (toolkit) {
+            toolkit->Init(PR_GetCurrentThread());
+
+            PR_SetThreadPrivate(gToolkitTLSIndex, (void*)toolkit.get());
+        } else {
+            rv = NS_ERROR_OUT_OF_MEMORY;
+        }
+    }
+
+    NS_IF_ADDREF(*aResult = toolkit);
+
+    return rv;
+}
diff --git a/widget/src/uikit/nsWidgetFactory.mm b/widget/src/uikit/nsWidgetFactory.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsWidgetFactory.mm
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIFactory.h"
+#include "nsISupports.h"
+#include "nsIComponentManager.h"
+#include "nsIGenericFactory.h"
+
+#include "nsWidgetsCID.h"
+
+#include "nsAppShell.h"
+#include "nsAppShellSingleton.h"
+#include "nsLookAndFeel.h"
+#include "nsScreenManager.h"
+#include "nsToolkit.h"
+#include "nsWindow.h"
+
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsLookAndFeel)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsScreenManager)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsToolkit)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsWindow)
+
+static const nsModuleComponentInfo gComponents[] =
+{
+  { "AppShell",
+    NS_APPSHELL_CID,
+    "@mozilla.org/widget/appshell/uikit;1",
+    nsAppShellConstructor },
+  { "Toolkit",
+    NS_TOOLKIT_CID,
+    "@mozilla.org/widget/toolkit/uikit;1",
+    nsToolkitConstructor },
+  { "nsWindow",
+    NS_WINDOW_CID,
+    "@mozilla.org/widgets/window/uikit;1",
+    nsWindowConstructor },
+  { "Child nsWindow",
+    NS_CHILD_CID,
+    "@mozilla.org/widgets/childwindow/uikit;1",
+    nsWindowConstructor }, // Same as nsWindow
+  /*
+  { "Popup nsWindow",
+    NS_POPUP_CID,
+    "@mozilla.org/widgets/popup/mac;1",
+    nsCocoaWindowConstructor },
+  */
+  { "Look And Feel",
+    NS_LOOKANDFEEL_CID,
+    "@mozilla.org/widget/lookandfeel/uikit;1",
+    nsLookAndFeelConstructor },
+  { "Screen Manager",
+    NS_SCREENMANAGER_CID,
+    "@mozilla.org/gfx/screenmanager;1",
+    nsScreenManagerConstructor },
+};
+
+NS_IMPL_NSGETMODULE_WITH_CTOR_DTOR(nsWidgetUIKitModule, gComponents,
+                                   nsAppShellInit, nsAppShellShutdown)
diff --git a/widget/src/uikit/nsWindow.h b/widget/src/uikit/nsWindow.h
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsWindow.h
@@ -0,0 +1,175 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Android code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ted Mielczarek <ted.mielczarek@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef NSWINDOW_H_
+#define NSWINDOW_H_
+
+#include "nsBaseWidget.h"
+#include "gfxPoint.h"
+
+#include "nsTArray.h"
+
+@class UIWindow;
+@class UIView;
+@class ChildView;
+class gfxASurface;
+
+class nsWindow :
+    public nsBaseWidget
+{
+public:
+    nsWindow();
+    virtual ~nsWindow();
+
+    NS_DECL_ISUPPORTS_INHERITED
+
+    void Redraw();
+
+    void InitEvent(nsGUIEvent& event, nsIntPoint* aPoint = 0);
+
+    //
+    // nsIWidget
+    //
+
+    NS_IMETHOD Create(nsIWidget *aParent,
+                      nsNativeWidget aNativeParent,
+                      const nsIntRect &aRect,
+                      EVENT_CALLBACK aHandleEventFunction,
+                      nsIDeviceContext *aContext,
+                      nsIAppShell *aAppShell,
+                      nsIToolkit *aToolkit,
+                      nsWidgetInitData *aInitData);
+    NS_IMETHOD Destroy(void);
+    NS_IMETHOD ConfigureChildren(const nsTArray<nsIWidget::Configuration>&);
+    NS_IMETHOD SetParent(nsIWidget* aNewParent);
+    virtual nsIWidget *GetParent(void);
+    NS_IMETHOD Show(PRBool aState);
+    NS_IMETHOD SetModal(PRBool aModal);
+    NS_IMETHOD IsVisible(PRBool & aState);
+    NS_IMETHOD ConstrainPosition(PRBool aAllowSlop,
+                                 PRInt32 *aX,
+                                 PRInt32 *aY);
+    NS_IMETHOD Move(PRInt32 aX,
+                    PRInt32 aY);
+    NS_IMETHOD Resize(PRInt32 aWidth,
+                      PRInt32 aHeight,
+                      PRBool  aRepaint);
+    NS_IMETHOD Resize(PRInt32 aX,
+                      PRInt32 aY,
+                      PRInt32 aWidth,
+                      PRInt32 aHeight,
+                      PRBool aRepaint);
+    NS_IMETHOD SetZIndex(PRInt32 aZIndex);
+    NS_IMETHOD PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
+                           nsIWidget *aWidget,
+                           PRBool aActivate);
+    NS_IMETHOD SetSizeMode(PRInt32 aMode);
+    NS_IMETHOD Enable(PRBool aState);
+    NS_IMETHOD IsEnabled(PRBool *aState);
+    NS_IMETHOD Invalidate(const nsIntRect &aRect,
+                          PRBool aIsSynchronous);
+    NS_IMETHOD Update();
+    void Scroll(const nsIntPoint&,
+                const nsTArray<nsIntRect>&,
+                const nsTArray<nsIWidget::Configuration>&);
+    NS_IMETHOD SetFocus(PRBool aRaise = PR_FALSE);
+    NS_IMETHOD GetScreenBounds(nsIntRect &aRect);
+    virtual nsIntPoint WidgetToScreenOffset();
+    static  PRBool          ConvertStatus(nsEventStatus aStatus)
+    { return aStatus == nsEventStatus_eConsumeNoDefault; }
+
+    NS_IMETHOD DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus);
+    PRBool DispatchWindowEvent(nsGUIEvent &event);
+
+    NS_IMETHOD SetForegroundColor(const nscolor &aColor) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetBackgroundColor(const nscolor &aColor);
+    NS_IMETHOD SetCursor(nsCursor aCursor) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetCursor(imgIContainer* aCursor,
+                         PRUint32 aHotspotX,
+                         PRUint32 aHotspotY) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetHasTransparentBackground(PRBool aTransparent) { return NS_OK; }
+    NS_IMETHOD GetHasTransparentBackground(PRBool& aTransparent) { aTransparent = PR_FALSE; return NS_OK; }
+    NS_IMETHOD HideWindowChrome(PRBool aShouldHide) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD MakeFullScreen(PRBool aFullScreen) { return NS_ERROR_NOT_IMPLEMENTED; }
+    virtual void* GetNativeData(PRUint32 aDataType);
+    NS_IMETHOD SetTitle(const nsAString& aTitle) { return NS_OK; }
+    NS_IMETHOD SetIcon(const nsAString& aIconSpec) { return NS_OK; }
+    NS_IMETHOD EnableDragDrop(PRBool aEnable) { return NS_OK; }
+    NS_IMETHOD CaptureMouse(PRBool aCapture) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD CaptureRollupEvents(nsIRollupListener *aListener,
+                                   nsIMenuRollup *aMenuRollup,
+                                   PRBool aDoCapture,
+                                   PRBool aConsumeRollupEvent) { return NS_ERROR_NOT_IMPLEMENTED; }
+
+    NS_IMETHOD GetAttention(PRInt32 aCycleCount) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical) { return NS_ERROR_NOT_IMPLEMENTED; }
+
+    NS_IMETHOD SetIMEEnabled(PRUint32 aState) { return NS_ERROR_NOT_IMPLEMENTED; };
+    NS_IMETHOD GetIMEEnabled(PRUint32* aState) { return NS_ERROR_NOT_IMPLEMENTED; };
+
+    gfxASurface* GetThebesSurface();
+
+protected:
+    void BringToFront();
+    nsWindow *FindTopLevel();
+    PRBool DrawTo(gfxASurface *targetSurface);
+    PRBool IsTopLevel();
+    nsresult GetCurrentOffset(PRUint32 &aOffset, PRUint32 &aLength);
+    nsresult DeleteRange(int aOffset, int aLen);
+    PRBool ReportDestroyEvent();
+    PRBool ReportMoveEvent();
+    PRBool ReportSizeEvent();
+
+    void TearDownView();
+
+    // This will be NULL for non-top-level windows
+    UIWindow* mNativeWindow;
+    // UIWindow subclasses UIView, so this is always valid
+    ChildView*   mNativeView;
+    PRPackedBool mVisible;
+    nsTArray<nsWindow*> mChildren;
+    nsWindow* mParent;
+    nsRefPtr<gfxASurface> mTempThebesSurface;
+
+    void OnSizeChanged(const gfxIntSize& aSize);
+
+    static void DumpWindows();
+    static void DumpWindows(const nsTArray<nsWindow*>& wins, int indent = 0);
+    static void LogWindow(nsWindow *win, int index, int indent);
+};
+
+#endif /* NSWINDOW_H_ */
diff --git a/widget/src/uikit/nsWindow.mm b/widget/src/uikit/nsWindow.mm
new file mode 100644
--- /dev/null
+++ b/widget/src/uikit/nsWindow.mm
@@ -0,0 +1,780 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Android code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#import <UIKit/UIEvent.h>
+#import <UIKit/UIGraphics.h>
+#import <UIKit/UIInterface.h>
+#import <UIKit/UIScreen.h>
+#import <UIKit/UITouch.h>
+#import <UIKit/UIView.h>
+#import <UIKit/UIWindow.h>
+
+#include "nsWindow.h"
+#include "nsScreenManager.h"
+#include "nsAppShell.h"
+
+#include "nsIDeviceContext.h"
+#include "nsIRenderingContext.h"
+
+#include "nsWidgetsCID.h"
+#include "nsGfxCIID.h"
+
+#include "gfxImageSurface.h"
+#include "gfxQuartzSurface.h"
+#include "gfxContext.h"
+#include "nsRegion.h"
+#include "Layers.h"
+
+#include "nsTArray.h"
+
+#define ALOG(args...) printf(args); printf("\n")
+
+static inline void
+GeckoRectToCGRect(const nsIntRect & inGeckoRect, CGRect & outRect)
+{
+  outRect.origin.x = inGeckoRect.x;
+  outRect.origin.y = inGeckoRect.y;
+  outRect.size.width = inGeckoRect.width;
+  outRect.size.height = inGeckoRect.height;
+}
+
+// Used to retain a Cocoa object for the remainder of a method's execution.
+class nsAutoRetainUIKitObject {
+public:
+nsAutoRetainUIKitObject(id anObject)
+{
+  mObject = [anObject retain];
+}
+~nsAutoRetainUIKitObject()
+{
+  [mObject release];
+}
+private:
+  id mObject;  // [STRONG]
+};
+
+@interface ChildView : UIView
+{
+@public
+    nsWindow* mGeckoChild; // weak ref
+}
+// sets up our view, attaching it to its owning gecko view
+- (id)initWithFrame:(CGRect)inFrame geckoChild:(nsWindow*)inChild;
+// Our Gecko child was Destroy()ed
+- (void)widgetDestroyed;
+// Tear down this ChildView
+- (void)delayedTearDown;
+// Event handling (UIResponder)
+- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
+- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
+- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
+- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
+@end
+
+@implementation ChildView
+- (id)initWithFrame:(CGRect)inFrame geckoChild:(nsWindow*)inChild
+{
+    if ((self = [super initWithFrame:inFrame])) {
+      mGeckoChild = inChild;
+    }
+    ALOG("[ChildView[%p] initWithFrame:] (mGeckoChild = %p)", (void*)self, (void*)mGeckoChild);
+    return self;
+}
+
+- (void)widgetDestroyed
+{
+  mGeckoChild = nsnull;
+}
+
+- (void)delayedTearDown
+{
+  ALOG("[ChildView[%p] delayedTearDown] (mGeckoChild = %p)", (void*)self, (void*)mGeckoChild);
+  [self removeFromSuperview];
+  [self release];
+}
+
+- (void)initGeckoEvent:(nsInputEvent*)outGeckoEvent
+{
+  outGeckoEvent->widget = mGeckoChild;
+  outGeckoEvent->time = PR_IntervalNow();
+}
+
+- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
+{
+    if (!mGeckoChild)
+        return;
+
+    if ([touches count] != 1) // ignore multitouch for now
+        return;
+
+    UITouch* theTouch = [touches anyObject];
+
+    nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
+    geckoEvent.clickCount = theTouch.tapCount;
+    geckoEvent.button = nsMouseEvent::eLeftButton;
+
+    [self initGeckoEvent:&geckoEvent];
+
+    // convert point to view coordinate system
+    CGPoint loc = [theTouch locationInView:self];
+   geckoEvent.refPoint.x = static_cast<nscoord>(loc.x);
+   geckoEvent.refPoint.y = static_cast<nscoord>(loc.y);
+
+    mGeckoChild->DispatchWindowEvent(geckoEvent);
+}
+
+- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
+{
+    //XXX: handle like touchesEnded?
+}
+
+- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
+{
+    if (!mGeckoChild)
+        return;
+
+    if ([touches count] != 1) // ignore multitouch for now
+        return;
+
+    UITouch* theTouch = [touches anyObject];
+
+    nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
+
+    geckoEvent.button = nsMouseEvent::eLeftButton;
+    geckoEvent.clickCount = theTouch.tapCount;
+    [self initGeckoEvent:&geckoEvent];
+
+    // convert point to view coordinate system
+    CGPoint loc = [theTouch locationInView:self];
+   geckoEvent.refPoint.x = static_cast<nscoord>(loc.x);
+   geckoEvent.refPoint.y = static_cast<nscoord>(loc.y);
+
+    mGeckoChild->DispatchWindowEvent(geckoEvent);
+}
+
+- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
+{
+    if (!mGeckoChild)
+        return;
+
+    if ([touches count] != 1) // ignore multitouch for now
+        return;
+
+    UITouch* theTouch = [touches anyObject];
+
+    nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
+    geckoEvent.button = nsMouseEvent::eLeftButton;
+    geckoEvent.clickCount = theTouch.tapCount;
+    [self initGeckoEvent:&geckoEvent];
+
+    // convert point to view coordinate system
+    CGPoint loc = [theTouch locationInView:self];
+   geckoEvent.refPoint.x = static_cast<nscoord>(loc.x);
+   geckoEvent.refPoint.y = static_cast<nscoord>(loc.y);
+
+    mGeckoChild->DispatchWindowEvent(geckoEvent);
+}
+
+// The display system has told us that a portion of our view is dirty. Tell
+// gecko to paint it
+- (void)drawRect:(CGRect)aRect
+{
+  ALOG("[ChildView[%p] drawRect:] (mGeckoChild = %p)", (void*)self, (void*)mGeckoChild);
+  if (!mGeckoChild)
+      return;
+  CGContextRef cgContext = UIGraphicsGetCurrentContext();
+  CGAffineTransform xform = CGContextGetCTM(cgContext);
+
+  nsPaintEvent paintEvent(PR_TRUE, NS_PAINT, mGeckoChild);
+  paintEvent.region =
+      nsIntRect(aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height);
+
+  // Subtract child view rectangles from the region
+  NSArray* subviews = [self subviews];
+  for (int i = 0; i < int([subviews count]); ++i) {
+    UIView* view = [subviews objectAtIndex:i];
+    if (![view isKindOfClass:[ChildView class]] || [view isHidden])
+      continue;
+    CGRect frame = [self convertRect:[view frame] fromView:view];
+    paintEvent.region.Sub(paintEvent.region,
+      nsIntRect(frame.origin.x, frame.origin.y, frame.size.width, frame.size.height));
+  }
+
+  // Create Cairo objects.
+  CGSize bufferSize = [self bounds].size;
+  nsRefPtr<gfxQuartzSurface> targetSurface =
+    new gfxQuartzSurface(cgContext, gfxSize(bufferSize.width, bufferSize.height));
+
+  nsRefPtr<gfxContext> targetContext = new gfxContext(targetSurface);
+
+  // Set up the clip region.
+  nsIntRegionRectIterator iter(paintEvent.region);
+  targetContext->NewPath();
+  for (;;) {
+    const nsIntRect* r = iter.Next();
+    if (!r)
+      break;
+    targetContext->Rectangle(gfxRect(r->x, r->y, r->width, r->height));
+  }
+  targetContext->Clip();
+
+  nsAutoRetainUIKitObject kungFuDeathGrip(self);
+  PRBool painted;
+  {
+    nsBaseWidget::AutoLayerManagerSetup setupLayerManager(mGeckoChild, targetContext);
+    painted = mGeckoChild->DispatchWindowEvent(paintEvent);
+  }
+
+  if (!painted && [self isOpaque]) {
+    // Gecko refused to draw, but we've claimed to be opaque, so we have to
+    // draw something--fill with white.
+    CGContextSetRGBFillColor(cgContext, 1, 1, 1, 1);
+    CGContextFillRect(cgContext, CGRectMake(aRect.origin.x, aRect.origin.y,
+                                            aRect.size.width, aRect.size.height));
+  }
+}
+@end
+
+NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
+
+nsWindow::nsWindow()
+: mNativeWindow(NULL),
+  mNativeView(NULL),
+  mVisible(PR_FALSE),
+  mParent(NULL),
+  mTempThebesSurface(NULL)
+{
+}
+
+nsWindow::~nsWindow()
+{
+    [mNativeView widgetDestroyed]; // Safe if mNativeView is nil.
+    TearDownView(); // Safe if called twice.
+}
+
+void nsWindow::TearDownView()
+{
+  if (!mNativeView)
+    return;
+
+  [mNativeView performSelectorOnMainThread:@selector(delayedTearDown) withObject:nil waitUntilDone:false];
+  mNativeView = nil;
+}
+
+PRBool
+nsWindow::IsTopLevel()
+{
+    return mWindowType == eWindowType_toplevel ||
+        mWindowType == eWindowType_dialog ||
+        mWindowType == eWindowType_invisible;
+}
+
+void nsWindow::Redraw()
+{
+  ALOG("nsWindow[%p]::Redraw");
+    [mNativeView setNeedsDisplay];
+}
+
+void nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
+{
+}
+
+//
+// nsIWidget
+//
+
+NS_IMETHODIMP
+nsWindow::Create(nsIWidget *aParent,
+                 nsNativeWidget aNativeParent,
+                 const nsIntRect &aRect,
+                 EVENT_CALLBACK aHandleEventFunction,
+                 nsIDeviceContext *aContext,
+                 nsIAppShell *aAppShell,
+                 nsIToolkit *aToolkit,
+                 nsWidgetInitData *aInitData)
+{
+    ALOG("nsWindow[%p]::Create %p/%p [%d %d %d %d]", (void*)this, (void*)aParent, (void*)aNativeParent, aRect.x, aRect.y, aRect.width, aRect.height);
+    nsWindow* parent = (nsWindow*) aParent;
+    ChildView* nativeParent = (ChildView*)aNativeParent;
+
+    if (parent == NULL && nativeParent)
+        parent = nativeParent->mGeckoChild;
+    if (parent && nativeParent == NULL)
+        nativeParent = parent->mNativeView;
+
+    // for toplevel windows, bounds are fixed to full screen size
+    if (parent == NULL) {
+        mBounds = nsScreenManager::GetBounds();
+    }
+    else {
+        mBounds = aRect;
+    }
+
+    ALOG("nsWindow[%p]::Create bounds: %d %d %d %d", (void*)this,
+         mBounds.x, mBounds.y, mBounds.width, mBounds.height);
+
+    BaseCreate(nsnull, mBounds, aHandleEventFunction, aContext,
+               aAppShell, aToolkit, aInitData);
+
+    NS_ASSERTION(IsTopLevel() || parent, "non top level window doesn't have a parent!");
+
+    CGRect cgRect;
+    cgRect.origin.x = mBounds.x;
+    cgRect.origin.y = mBounds.y;
+    cgRect.size.width = mBounds.width;
+    cgRect.size.height = mBounds.height;
+
+    if (IsTopLevel()) {
+        mNativeWindow = [[UIWindow alloc] initWithFrame:cgRect];
+        ALOG("nsWindow[%p]::Create: mNativeWindow: %p", (void*)this, (void*)mNativeWindow);
+    }
+
+    mNativeView = [[ChildView alloc] initWithFrame:cgRect geckoChild:this];
+    ALOG("nsWindow[%p]::Create: mNativeView: %p", (void*)this, (void*)mNativeView);
+    if (mNativeWindow)
+        [mNativeWindow addSubview:mNativeView];
+
+    if (parent) {
+        parent->mChildren.AppendElement(this);
+        mParent = parent;
+
+        ALOG("nsWindow[%p]::Create [aNativeParent(%p) addSubview:%p]", (void*)this, (void*)nativeParent, (void*)mNativeView);
+        [nativeParent addSubview:mNativeView];
+    }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Destroy(void)
+{
+    ALOG("nsWindow[%p]::Destroy (mNativeView = %p)", (void*)this, (void*)mNativeView);
+    for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
+        // why do we still have children?
+        ALOG("### Warning: Destroying window %p and reparenting child %p to null!", (void*)this, (void*)mChildren[i]);
+        mChildren[i]->SetParent(nsnull);
+    }
+
+    if (mParent)
+        mParent->mChildren.RemoveElement(this);
+
+    [mNativeView widgetDestroyed];
+
+    nsBaseWidget::Destroy();
+
+    ReportDestroyEvent(); 
+
+    TearDownView();
+
+    nsBaseWidget::OnDestroy();
+
+    if (mNativeWindow) {
+        [mNativeWindow release];
+        mNativeWindow = nil;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::ConfigureChildren(const nsTArray<nsIWidget::Configuration>& config)
+{
+    for (PRUint32 i = 0; i < config.Length(); ++i) {
+        nsWindow *childWin = (nsWindow*) config[i].mChild;
+        childWin->Resize(config[i].mBounds.x,
+                         config[i].mBounds.y,
+                         config[i].mBounds.width,
+                         config[i].mBounds.height,
+                         PR_FALSE);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetParent(nsIWidget* aNewParent)
+{
+  ALOG("nsWindow[%p]::SetParent(%p)", (void*)this, (void*)aNewParent);
+  if ((nsIWidget*)mParent == aNewParent)
+    return NS_OK;
+
+  if (mParent) {
+    mParent->mChildren.RemoveElement(this);
+    [mNativeView removeFromSuperview];
+  }
+
+  mParent = (nsWindow*)aNewParent;
+
+  if (mParent) {
+    mParent->mChildren.AppendElement(this);
+    ALOG("nsWindow[%p]::Create [mParent(%p)->mNativeView(%p) addSubview:%p]", (void*)this, (void*)mParent, (void*)mParent->mNativeView, (void*)mNativeView);
+    [mParent->mNativeView addSubview:mNativeView];
+  }
+  //nsAppShell::ScheduleRedraw(); ?
+  return NS_OK;
+}
+
+nsIWidget *nsWindow::GetParent(void)
+{
+  return mParent;
+}
+
+NS_IMETHODIMP
+nsWindow::Show(PRBool aState)
+{
+  ALOG("nsWindow[%p]::Show(%d) (toplevel: %d)", (void*)this, aState, mNativeWindow != NULL);
+  if (aState != mVisible) {
+    if (mNativeWindow && aState)
+      [mNativeWindow makeKeyAndVisible];
+    [mNativeView setHidden:!aState];
+    mVisible = aState;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetModal(PRBool aModal)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::IsVisible(PRBool & aState)
+{
+  aState = mVisible;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::ConstrainPosition(PRBool aAllowSlop,
+                            PRInt32 *aX,
+                            PRInt32 *aY)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Move(PRInt32 aX,
+               PRInt32 aY)
+{
+  if (!mNativeView || (mBounds.x == aX && mBounds.y == aY))
+    return NS_OK;
+
+  mBounds.x = aX;
+  mBounds.y = aY;
+
+  CGRect r;
+  GeckoRectToCGRect(mBounds, r);
+  mNativeView.frame = r;
+
+  if (mVisible)
+    [mNativeView setNeedsDisplay];
+
+  ReportMoveEvent();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Resize(PRInt32 aWidth,
+                 PRInt32 aHeight,
+                 PRBool  aRepaint)
+{
+  if (!mNativeView || (mBounds.width == aWidth && mBounds.height == aHeight))
+    return NS_OK;
+
+  mBounds.width  = aWidth;
+  mBounds.height = aHeight;
+
+  CGRect r;
+  GeckoRectToCGRect(mBounds, r);
+  [mNativeView setFrame:r];
+
+  if (mVisible && aRepaint)
+    [mNativeView setNeedsDisplay];
+
+  ReportSizeEvent();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Resize(PRInt32 aX,
+                 PRInt32 aY,
+                 PRInt32 aWidth,
+                 PRInt32 aHeight,
+                 PRBool aRepaint)
+{
+  BOOL isMoving = (mBounds.x != aX || mBounds.y != aY);
+  BOOL isResizing = (mBounds.width != aWidth || mBounds.height != aHeight);
+  if (!mNativeView || (!isMoving && !isResizing))
+    return NS_OK;
+
+  if (isMoving) {
+    mBounds.x = aX;
+    mBounds.y = aY;
+  }
+  if (isResizing) {
+    mBounds.width  = aWidth;
+    mBounds.height = aHeight;
+  }
+
+  CGRect r;
+  GeckoRectToCGRect(mBounds, r);
+  [mNativeView setFrame:r];
+
+  if (mVisible && aRepaint)
+    [mNativeView setNeedsDisplay];
+
+  if (isMoving) 
+    ReportMoveEvent();
+
+  if (isResizing)
+    ReportSizeEvent();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetZIndex(PRInt32 aZIndex)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
+                      nsIWidget *aWidget,
+                      PRBool aActivate)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetSizeMode(PRInt32 aMode)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Enable(PRBool aState)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::IsEnabled(PRBool *aState)
+{
+  *aState = PR_TRUE;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Invalidate(const nsIntRect &aRect,
+                     PRBool aIsSynchronous)
+{
+  ALOG("nsWindow[%p]::Invalidate");
+  if (!mNativeView || !mVisible)
+    return NS_OK;
+
+  CGRect r;
+  GeckoRectToCGRect(aRect, r);
+  //XXX: handle aIsSynchronous?
+  [mNativeView setNeedsDisplayInRect:r];
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Update()
+{
+  return NS_OK;
+}
+
+void nsWindow::Scroll(const nsIntPoint&,
+                      const nsTArray<nsIntRect>&,
+                      const nsTArray<nsIWidget::Configuration>&)
+{
+    //XXX: implement me
+}
+
+NS_IMETHODIMP
+nsWindow::SetFocus(PRBool aRaise)
+{
+  ALOG("nsWindow[%p]::SetFocus(%d)", (void*)this, aRaise);
+  [[mNativeView window] makeKeyWindow];
+  return NS_OK;
+}
+
+PRBool nsWindow::ReportDestroyEvent()
+{
+  nsGUIEvent event(PR_TRUE, NS_DESTROY, this);
+  event.time = PR_IntervalNow();
+  return DispatchWindowEvent(event);
+}
+
+PRBool nsWindow::ReportMoveEvent()
+{
+  nsGUIEvent moveEvent(PR_TRUE, NS_MOVE, this);
+  moveEvent.refPoint.x = mBounds.x;
+  moveEvent.refPoint.y = mBounds.y;
+  moveEvent.time       = PR_IntervalNow();
+  return DispatchWindowEvent(moveEvent);
+}
+
+PRBool nsWindow::ReportSizeEvent()
+{
+  nsSizeEvent sizeEvent(PR_TRUE, NS_SIZE, this);
+  sizeEvent.time        = PR_IntervalNow();
+  sizeEvent.windowSize  = &mBounds;
+  sizeEvent.mWinWidth   = mBounds.width;
+  sizeEvent.mWinHeight  = mBounds.height;
+  return DispatchWindowEvent(sizeEvent);
+}
+
+
+NS_IMETHODIMP
+nsWindow::GetScreenBounds(nsIntRect &aRect)
+{
+  nsIntPoint p = WidgetToScreenOffset();
+  aRect.x = p.x;
+  aRect.y = p.y;
+  aRect.width = mBounds.width;
+  aRect.height = mBounds.height;
+  ALOG("nsWindow[%p]::GetScreenBounds: [%d %d %d %d]", (void*)this,
+       aRect.x, aRect.y, aRect.width, aRect.height);
+
+  return NS_OK;
+}
+
+nsIntPoint nsWindow::WidgetToScreenOffset()
+{
+  CGPoint temp;
+  temp.x = 0;
+  temp.y = 0;
+  
+
+  if (mNativeWindow) {
+      // convert to screen coords
+      temp = [mNativeWindow convertPoint:temp toWindow:nil];
+      return nsIntPoint(NSToIntRound(temp.x), NSToIntRound(temp.y));
+  }
+
+  nsIntPoint offset;
+  if (mParent) {
+      offset = mParent->WidgetToScreenOffset();
+      temp = [mNativeView convertPoint:temp toView:nil];
+      offset.x += temp.x;
+      offset.y += temp.y;
+  }
+
+  return offset;
+}
+
+NS_IMETHODIMP
+nsWindow::DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus)
+{
+  aStatus = nsEventStatus_eIgnore;
+  nsCOMPtr<nsIWidget> kungFuDeathGrip = do_QueryInterface(mParent ? mParent : this);
+
+  if (mEventCallback)
+    aStatus = (*mEventCallback)(aEvent);
+
+  return NS_OK;
+}
+
+PRBool nsWindow::DispatchWindowEvent(nsGUIEvent &event)
+{
+  nsEventStatus status;
+  DispatchEvent(&event, status);
+  return ConvertStatus(status);
+}
+
+NS_IMETHODIMP
+nsWindow::SetBackgroundColor(const nscolor &aColor)
+{
+    mNativeView.backgroundColor = [UIColor colorWithRed:NS_GET_R(aColor)
+                                   green:NS_GET_G(aColor)
+                                   blue:NS_GET_B(aColor)
+                                   alpha:NS_GET_A(aColor)];
+    return NS_OK;
+}
+
+void* nsWindow::GetNativeData(PRUint32 aDataType)
+{
+  void* retVal = NULL;
+
+  switch (aDataType) 
+  {
+    case NS_NATIVE_WIDGET:
+    case NS_NATIVE_DISPLAY:
+      retVal = (void*)mNativeView;
+      break;
+
+    case NS_NATIVE_WINDOW:
+      retVal = [mNativeView window];
+      break;
+
+    case NS_NATIVE_GRAPHIC:
+      NS_ERROR("Requesting NS_NATIVE_GRAPHIC on a UIKit child view!");
+      break;
+
+    case NS_NATIVE_OFFSETX:
+      retVal = 0;
+      break;
+
+    case NS_NATIVE_OFFSETY:
+      retVal = 0;
+      break;
+
+    case NS_NATIVE_PLUGIN_PORT:
+    case NS_NATIVE_PLUGIN_PORT_QD:
+    case NS_NATIVE_PLUGIN_PORT_CG:
+        // not implemented
+        break;
+  }
+
+  return retVal;
+}
+
+gfxASurface* nsWindow::GetThebesSurface()
+{
+  if (!mTempThebesSurface) {
+    mTempThebesSurface = new gfxQuartzSurface(gfxSize(1, 1), gfxASurface::ImageFormatARGB32);
+  }
+
+  return mTempThebesSurface;
+}
