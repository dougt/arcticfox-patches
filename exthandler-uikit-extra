diff --git a/uriloader/exthandler/Makefile.in b/uriloader/exthandler/Makefile.in
--- a/uriloader/exthandler/Makefile.in
+++ b/uriloader/exthandler/Makefile.in
@@ -60,11 +60,15 @@
 ifeq ($(MOZ_WIDGET_TOOLKIT),beos)
 OSDIR		= beos
 else
+ifeq ($(MOZ_WIDGET_TOOLKIT),uikit)
+OSDIR		= uikit
+else
 OSDIR		= unix
 endif
 endif
 endif
 endif
+endif
 
 VPATH		:= $(srcdir) $(srcdir)/$(OSDIR)
 
@@ -80,8 +84,16 @@
 			nsLocalHandlerAppMac.mm \
 			$(NULL)
 else
+ifeq ($(MOZ_WIDGET_TOOLKIT),uikit)
+CMMSRCS	= \
+  nsOSHelperAppService.mm \
+  nsMIMEInfoUIKit.mm \
+  nsLocalHandlerAppUIKit.mm \
+  $(NULL)
+else
 OSHELPER	= nsOSHelperAppService.cpp
 endif
+endif
 
 LOCAL_INCLUDES = -I$(srcdir)
 
@@ -95,11 +107,6 @@
 OSHELPER += nsMIMEInfoUnix.cpp
 endif
 
-ifeq ($(MOZ_WIDGET_TOOLKIT),uikit)
-#XXX: fixme
-OSHELPER += nsMIMEInfoUnix.cpp
-endif
-
 ifeq ($(MOZ_WIDGET_TOOLKIT),beos)
 OSHELPER  += nsMIMEInfoBeOS.cpp
 endif
diff --git a/uriloader/exthandler/mac/nsLocalHandlerAppMac.h b/uriloader/exthandler/uikit/nsLocalHandlerAppUIKit.h
copy from uriloader/exthandler/mac/nsLocalHandlerAppMac.h
copy to uriloader/exthandler/uikit/nsLocalHandlerAppUIKit.h
--- a/uriloader/exthandler/mac/nsLocalHandlerAppMac.h
+++ b/uriloader/exthandler/uikit/nsLocalHandlerAppUIKit.h
@@ -35,25 +35,24 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#ifndef NSLOCALHANDLERAPPMAC_H_
-#define NSLOCALHANDLERAPPMAC_H_
+#ifndef NSLOCALHANDLERAPPUIKIT_H_
+#define NSLOCALHANDLERAPPUIKIT_H_
 
 #include "nsLocalHandlerApp.h"
 
-class nsLocalHandlerAppMac : public nsLocalHandlerApp {
+class nsLocalHandlerAppUIKit : public nsLocalHandlerApp {
 
   public:
-    nsLocalHandlerAppMac() { }
+    nsLocalHandlerAppUIKit() { }
 
-    nsLocalHandlerAppMac(const PRUnichar *aName, nsIFile *aExecutable)
+    nsLocalHandlerAppUIKit(const PRUnichar *aName, nsIFile *aExecutable)
       : nsLocalHandlerApp(aName, aExecutable) {} 
 
-    nsLocalHandlerAppMac(const nsAString & aName, nsIFile *aExecutable) 
+    nsLocalHandlerAppUIKit(const nsAString & aName, nsIFile *aExecutable) 
       : nsLocalHandlerApp(aName, aExecutable) {}
-    virtual ~nsLocalHandlerAppMac() { }
+    virtual ~nsLocalHandlerAppUIKit() { }
 
     NS_IMETHOD LaunchWithURI(nsIURI* aURI, nsIInterfaceRequestor* aWindowContext);
-    NS_IMETHOD GetName(nsAString& aName);
 };
 
-#endif /*NSLOCALHANDLERAPPMAC_H_*/
+#endif /*NSLOCALHANDLERAPPUIKIT_H_*/
diff --git a/uriloader/exthandler/mac/nsLocalHandlerAppMac.mm b/uriloader/exthandler/uikit/nsLocalHandlerAppUIKit.mm
copy from uriloader/exthandler/mac/nsLocalHandlerAppMac.mm
copy to uriloader/exthandler/uikit/nsLocalHandlerAppUIKit.mm
--- a/uriloader/exthandler/mac/nsLocalHandlerAppMac.mm
+++ b/uriloader/exthandler/uikit/nsLocalHandlerAppUIKit.mm
@@ -36,82 +36,13 @@
  * ***** END LICENSE BLOCK ***** */
 
 #import <CoreFoundation/CoreFoundation.h>
-#import <ApplicationServices/ApplicationServices.h>
 
-#include "nsObjCExceptions.h"
-#include "nsLocalHandlerAppMac.h"
-#include "nsILocalFileMac.h"
+#include "nsLocalHandlerAppUIKit.h"
 #include "nsIURI.h"
 
-// We override this to make sure app bundles display their pretty name (without .app suffix)
-NS_IMETHODIMP nsLocalHandlerAppMac::GetName(nsAString& aName)
-{
-  if (mExecutable) {
-    nsCOMPtr<nsILocalFileMac> macFile = do_QueryInterface(mExecutable);
-    if (macFile) {
-      PRBool isPackage;
-      (void)macFile->IsPackage(&isPackage);
-      if (isPackage)
-        return macFile->GetBundleDisplayName(aName);
-    }
-  }
-
-  return nsLocalHandlerApp::GetName(aName);
-}
-
-/** 
- * mostly copy/pasted from nsMacShellService.cpp (which is in browser/,
- * so we can't depend on it here).  This code probably really wants to live
- * somewhere more central (see bug 389922).
- */
 NS_IMETHODIMP
-nsLocalHandlerAppMac::LaunchWithURI(nsIURI *aURI,
+nsLocalHandlerAppUIKit::LaunchWithURI(nsIURI *aURI,
                                     nsIInterfaceRequestor *aWindowContext)
 {
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
-
-  nsresult rv;
-  nsCOMPtr<nsILocalFileMac> lfm(do_QueryInterface(mExecutable, &rv));
-  NS_ENSURE_SUCCESS(rv, rv);
-  
-  CFURLRef appURL;
-  rv = lfm->GetCFURL(&appURL);
-  if (NS_FAILED(rv))
-    return rv;
-  
-  nsCAutoString uriSpec;
-  aURI->GetAsciiSpec(uriSpec);
-
-  const UInt8* uriString = reinterpret_cast<const UInt8*>(uriSpec.get());
-  CFURLRef uri = ::CFURLCreateWithBytes(NULL, uriString, uriSpec.Length(),
-                                        kCFStringEncodingUTF8, NULL);
-  if (!uri) {
-    ::CFRelease(appURL);
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  
-  CFArrayRef uris = ::CFArrayCreate(NULL, reinterpret_cast<const void**>(&uri),
-                                    1, NULL);
-  if (!uris) {
-    ::CFRelease(uri);
-    ::CFRelease(appURL);
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  
-  LSLaunchURLSpec launchSpec;
-  launchSpec.appURL = appURL;
-  launchSpec.itemURLs = uris;
-  launchSpec.passThruParams = NULL;
-  launchSpec.launchFlags = kLSLaunchDefaults;
-  launchSpec.asyncRefCon = NULL;
-  
-  OSErr err = ::LSOpenFromURLSpec(&launchSpec, NULL);
-  
-  ::CFRelease(uris);
-  ::CFRelease(uri);
-  ::CFRelease(appURL);
-  
-  return err != noErr ? NS_ERROR_FAILURE : NS_OK;
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
diff --git a/uriloader/exthandler/mac/nsMIMEInfoMac.h b/uriloader/exthandler/uikit/nsMIMEInfoUIKit.h
copy from uriloader/exthandler/mac/nsMIMEInfoMac.h
copy to uriloader/exthandler/uikit/nsMIMEInfoUIKit.h
--- a/uriloader/exthandler/mac/nsMIMEInfoMac.h
+++ b/uriloader/exthandler/uikit/nsMIMEInfoUIKit.h
@@ -35,16 +35,16 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#ifndef nsMIMEInfoMac_h_
-#define nsMIMEInfoMac_h_
+#ifndef nsMIMEInfoUIKit_h_
+#define nsMIMEInfoUIKit_h_
 
 #include "nsMIMEInfoImpl.h"
 
-class nsMIMEInfoMac : public nsMIMEInfoImpl {
+class nsMIMEInfoUIKit : public nsMIMEInfoImpl {
   public:
-    nsMIMEInfoMac(const char* aMIMEType = "") : nsMIMEInfoImpl(aMIMEType) {}
-    nsMIMEInfoMac(const nsACString& aMIMEType) : nsMIMEInfoImpl(aMIMEType) {}
-    nsMIMEInfoMac(const nsACString& aType, HandlerClass aClass) :
+    nsMIMEInfoUIKit(const char* aMIMEType = "") : nsMIMEInfoImpl(aMIMEType) {}
+    nsMIMEInfoUIKit(const nsACString& aMIMEType) : nsMIMEInfoImpl(aMIMEType) {}
+    nsMIMEInfoUIKit(const nsACString& aType, HandlerClass aClass) :
       nsMIMEInfoImpl(aType, aClass) {}
 
     NS_IMETHOD LaunchWithFile(nsIFile* aFile);
@@ -58,9 +58,6 @@
 #endif
     static NS_HIDDEN_(nsresult) OpenApplicationWithURI(nsIFile *aApplication, 
                                                        const nsCString& aURI);
-                                                       
-    NS_IMETHOD GetDefaultDescription(nsAString& aDefaultDescription);
-    
 };
 
 
diff --git a/uriloader/exthandler/mac/nsMIMEInfoMac.mm b/uriloader/exthandler/uikit/nsMIMEInfoUIKit.mm
copy from uriloader/exthandler/mac/nsMIMEInfoMac.mm
copy to uriloader/exthandler/uikit/nsMIMEInfoUIKit.mm
--- a/uriloader/exthandler/mac/nsMIMEInfoMac.mm
+++ b/uriloader/exthandler/uikit/nsMIMEInfoUIKit.mm
@@ -40,112 +40,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#import <ApplicationServices/ApplicationServices.h>
-
-#include "nsObjCExceptions.h"
-#include "nsMIMEInfoMac.h"
-#include "nsILocalFileMac.h"
+#include "nsMIMEInfoUIKit.h"
 #include "nsIFileURL.h"
 
-// We override this to make sure app bundles display their pretty name (without .app suffix)
-NS_IMETHODIMP nsMIMEInfoMac::GetDefaultDescription(nsAString& aDefaultDescription)
+NS_IMETHODIMP
+nsMIMEInfoUIKit::LaunchWithFile(nsIFile *aFile)
 {
-  if (mDefaultApplication) {
-    nsCOMPtr<nsILocalFileMac> macFile = do_QueryInterface(mDefaultApplication);
-    if (macFile) {
-      PRBool isPackage;
-      (void)macFile->IsPackage(&isPackage);
-      if (isPackage)
-        return macFile->GetBundleDisplayName(aDefaultDescription);
-    }
-  }
-
-  return nsMIMEInfoImpl::GetDefaultDescription(aDefaultDescription);
-}
-
-NS_IMETHODIMP
-nsMIMEInfoMac::LaunchWithFile(nsIFile *aFile)
-{
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
-
-  nsCOMPtr<nsIFile> application;
-  nsresult rv;
-
-  NS_ASSERTION(mClass == eMIMEInfo, "only MIME infos are currently allowed"
-               "to pass content by value");
-  
-  if (mPreferredAction == useHelperApp) {
-
-    // we don't yet support passing content by value (rather than reference)
-    // to web apps.  at some point, we will probably want to.  
-    nsCOMPtr<nsILocalHandlerApp> localHandlerApp =
-        do_QueryInterface(mPreferredApplication, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-    
-    rv = localHandlerApp->GetExecutable(getter_AddRefs(application));
-    NS_ENSURE_SUCCESS(rv, rv);
-    
-  } else if (mPreferredAction == useSystemDefault) {
-    application = mDefaultApplication;
-  }
-  else
-    return NS_ERROR_INVALID_ARG;
-
-  // if we've already got an app, just QI so we have the launchWithDoc method
-  nsCOMPtr<nsILocalFileMac> app;
-  if (application) {
-    app = do_QueryInterface(application, &rv);
-    if (NS_FAILED(rv)) return rv;
-  } else {
-    // otherwise ask LaunchServices for an app directly
-    nsCOMPtr<nsILocalFileMac> tempFile = do_QueryInterface(aFile, &rv);
-    if (NS_FAILED(rv)) return rv;
-
-    FSRef tempFileRef;
-    tempFile->GetFSRef(&tempFileRef);
-
-    FSRef appFSRef;
-    if (::LSGetApplicationForItem(&tempFileRef, kLSRolesAll, &appFSRef, nsnull) == noErr)
-    {
-      app = (do_CreateInstance("@mozilla.org/file/local;1"));
-      if (!app) return NS_ERROR_FAILURE;
-      app->InitWithFSRef(&appFSRef);
-    } else {
-      return NS_ERROR_FAILURE;
-    }
-  }
-  nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(aFile);
-  return app->LaunchWithDoc(localFile, PR_FALSE);
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult 
-nsMIMEInfoMac::LoadUriInternal(nsIURI *aURI)
+nsMIMEInfoUIKit::LoadUriInternal(nsIURI *aURI)
 {
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
-
-  NS_ENSURE_ARG_POINTER(aURI);
-
-  nsresult rv = NS_ERROR_FAILURE;
-
-  nsCAutoString uri;
-  aURI->GetSpec(uri);
-  if (!uri.IsEmpty()) {
-    CFURLRef myURLRef = ::CFURLCreateWithBytes(kCFAllocatorDefault,
-                                               (const UInt8*)uri.get(),
-                                               strlen(uri.get()),
-                                               kCFStringEncodingUTF8,
-                                               NULL);
-    if (myURLRef) {
-      OSStatus status = ::LSOpenCFURLRef(myURLRef, NULL);
-      if (status == noErr)
-        rv = NS_OK;
-      ::CFRelease(myURLRef);
-    }
-  }
-
-  return rv;
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
diff --git a/uriloader/exthandler/mac/nsOSHelperAppService.h b/uriloader/exthandler/uikit/nsOSHelperAppService.h
copy from uriloader/exthandler/mac/nsOSHelperAppService.h
copy to uriloader/exthandler/uikit/nsOSHelperAppService.h
diff --git a/uriloader/exthandler/mac/nsOSHelperAppService.mm b/uriloader/exthandler/uikit/nsOSHelperAppService.mm
copy from uriloader/exthandler/mac/nsOSHelperAppService.mm
copy to uriloader/exthandler/uikit/nsOSHelperAppService.mm
--- a/uriloader/exthandler/mac/nsOSHelperAppService.mm
+++ b/uriloader/exthandler/uikit/nsOSHelperAppService.mm
@@ -40,57 +40,26 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsOSHelperAppService.h"
-#include "nsObjCExceptions.h"
 #include "nsISupports.h"
 #include "nsString.h"
 #include "nsTArray.h"
 #include "nsXPIDLString.h"
 #include "nsIURL.h"
 #include "nsILocalFile.h"
-#include "nsILocalFileMac.h"
 #include "nsMimeTypes.h"
 #include "nsIStringBundle.h"
 #include "nsIPromptService.h"
 #include "nsMemory.h"
 #include "nsCRT.h"
-#include "nsMIMEInfoMac.h"
+#include "nsMIMEInfoUIKit.h"
 #include "nsEmbedCID.h"
 
 #import <CoreFoundation/CoreFoundation.h>
-#import <ApplicationServices/ApplicationServices.h>
 
-// chrome URL's
+// chrome URLs
 #define HELPERAPPLAUNCHER_BUNDLE_URL "chrome://global/locale/helperAppLauncher.properties"
 #define BRAND_BUNDLE_URL "chrome://branding/locale/brand.properties"
 
-extern "C" {
-  // Returns the CFURL for application currently set as the default opener for
-  // the given URL scheme. appURL must be released by the caller.
-  extern OSStatus _LSCopyDefaultSchemeHandlerURL(CFStringRef scheme,
-                                                 CFURLRef *appURL);
-}
-
-/* This is an undocumented interface (in the Foundation framework) that has
- * been stable since at least 10.2.8 and is still present on SnowLeopard.
- * Furthermore WebKit has three public methods (in WebKitSystemInterface.h)
- * that are thin wrappers around this interface's last three methods.  So
- * it's unlikely to change anytime soon.  Now that we're no longer using
- * Internet Config Services, this is the only way to look up a MIME type
- * from an extension, or vice versa.
- */
-@class NSURLFileTypeMappingsInternal;
-
-@interface NSURLFileTypeMappings : NSObject
-{
-    NSURLFileTypeMappingsInternal *_internal;
-}
-
-+ (NSURLFileTypeMappings*)sharedMappings;
-- (NSString*)MIMETypeForExtension:(NSString*)aString;
-- (NSString*)preferredExtensionForMIMEType:(NSString*)aString;
-- (NSArray*)extensionsForMIMEType:(NSString*)aString;
-@end
-
 nsOSHelperAppService::nsOSHelperAppService() : nsExternalHelperAppService()
 {
 }
@@ -100,142 +69,18 @@
 
 nsresult nsOSHelperAppService::OSProtocolHandlerExists(const char * aProtocolScheme, PRBool * aHandlerExists)
 {
-  // CFStringCreateWithBytes() can fail even if we're not out of memory --
-  // for example if the 'bytes' parameter is something very wierd (like "ÿÿ~"
-  // aka "\xFF\xFF~"), or possibly if it can't be interpreted as using what's
-  // specified in the 'encoding' parameter.  See bug 548719.
-  CFStringRef schemeString = ::CFStringCreateWithBytes(kCFAllocatorDefault,
-                                                       (const UInt8*)aProtocolScheme,
-                                                       strlen(aProtocolScheme),
-                                                       kCFStringEncodingUTF8,
-                                                       false);
-  if (schemeString) {
-    // LSCopyDefaultHandlerForURLScheme() can fail to find the default handler
-    // for aProtocolScheme when it's never been explicitly set (using
-    // LSSetDefaultHandlerForURLScheme()).  For example, Safari is the default
-    // handler for the "http" scheme on a newly installed copy of OS X.  But
-    // this (presumably) wasn't done using LSSetDefaultHandlerForURLScheme(),
-    // so LSCopyDefaultHandlerForURLScheme() will fail to find Safari.  To get
-    // around this we use LSCopyAllHandlersForURLScheme() instead -- which seems
-    // never to fail.
-    // http://lists.apple.com/archives/Carbon-dev/2007/May/msg00349.html
-    // http://www.realsoftware.com/listarchives/realbasic-nug/2008-02/msg00119.html
-    CFArrayRef handlerArray = ::LSCopyAllHandlersForURLScheme(schemeString);
-    *aHandlerExists = !!handlerArray;
-    if (handlerArray)
-      ::CFRelease(handlerArray);
-    ::CFRelease(schemeString);
-  } else {
-    *aHandlerExists = PR_FALSE;
-  }
+  *aHandlerExists = PR_FALSE;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(const nsACString& aScheme, nsAString& _retval)
 {
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
-
-  nsresult rv = NS_ERROR_NOT_AVAILABLE;
-
-  CFStringRef schemeCFString = 
-    ::CFStringCreateWithBytes(kCFAllocatorDefault,
-                              (const UInt8 *)PromiseFlatCString(aScheme).get(),
-                              aScheme.Length(),
-                              kCFStringEncodingUTF8,
-                              false);
-  if (schemeCFString) {
-    // Since the public API (LSGetApplicationForURL) fails every now and then,
-    // we're using undocumented _LSCopyDefaultSchemeHandlerURL
-    CFURLRef handlerBundleURL;
-    OSStatus err = ::_LSCopyDefaultSchemeHandlerURL(schemeCFString,
-                                                    &handlerBundleURL);
-    if (err == noErr) {
-      CFBundleRef handlerBundle = ::CFBundleCreate(NULL, handlerBundleURL);
-      if (handlerBundle) {
-        // Get the human-readable name of the default handler bundle
-        CFStringRef bundleName =
-          (CFStringRef)::CFBundleGetValueForInfoDictionaryKey(handlerBundle,
-                                                              kCFBundleNameKey);
-        if (bundleName) {
-          nsAutoTArray<UniChar, 255> buffer;
-          CFIndex bundleNameLength = ::CFStringGetLength(bundleName);
-          buffer.SetLength(bundleNameLength);
-          ::CFStringGetCharacters(bundleName, CFRangeMake(0, bundleNameLength),
-                                  buffer.Elements());
-          _retval.Assign(buffer.Elements(), bundleNameLength);
-          rv = NS_OK;
-        }
-
-        ::CFRelease(handlerBundle);
-      }
-
-      ::CFRelease(handlerBundleURL);
-    }
-
-    ::CFRelease(schemeCFString);
-  }
-
-  return rv;
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+  return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsresult nsOSHelperAppService::GetFileTokenForPath(const PRUnichar * aPlatformAppPath, nsIFile ** aFile)
 {
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
-
-  nsresult rv;
-  nsCOMPtr<nsILocalFileMac> localFile (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &rv));
-  NS_ENSURE_SUCCESS(rv,rv);
-
-  CFURLRef pathAsCFURL;
-  CFStringRef pathAsCFString = ::CFStringCreateWithCharacters(NULL,
-                                                              aPlatformAppPath,
-                                                              nsCRT::strlen(aPlatformAppPath));
-  if (!pathAsCFString)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  if (::CFStringGetCharacterAtIndex(pathAsCFString, 0) == '/') {
-    // we have a Posix path
-    pathAsCFURL = ::CFURLCreateWithFileSystemPath(nsnull, pathAsCFString,
-                                                  kCFURLPOSIXPathStyle, PR_FALSE);
-    if (!pathAsCFURL) {
-      ::CFRelease(pathAsCFString);
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
-  else {
-    // if it doesn't start with a / it's not an absolute Posix path
-    // let's check if it's a HFS path left over from old preferences
-
-    // If it starts with a ':' char, it's not an absolute HFS path
-    // so bail for that, and also if it's empty
-    if (::CFStringGetLength(pathAsCFString) == 0 ||
-        ::CFStringGetCharacterAtIndex(pathAsCFString, 0) == ':')
-    {
-      ::CFRelease(pathAsCFString);
-      return NS_ERROR_FILE_UNRECOGNIZED_PATH;
-    }
-
-    pathAsCFURL = ::CFURLCreateWithFileSystemPath(nsnull, pathAsCFString,
-                                                  kCFURLHFSPathStyle, PR_FALSE);
-    if (!pathAsCFURL) {
-      ::CFRelease(pathAsCFString);
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
-
-  rv = localFile->InitWithCFURL(pathAsCFURL);
-  ::CFRelease(pathAsCFString);
-  ::CFRelease(pathAsCFURL);
-  if (NS_FAILED(rv))
-    return rv;
-  *aFile = localFile;
-  NS_IF_ADDREF(*aFile);
-
-  return NS_OK;
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsOSHelperAppService::GetFromTypeAndExtension(const nsACString& aType, const nsACString& aFileExt, nsIMIMEInfo ** aMIMEInfo)
@@ -243,205 +88,13 @@
   return nsExternalHelperAppService::GetFromTypeAndExtension(aType, aFileExt, aMIMEInfo);
 }
 
-// aMIMEType and aFileExt might not match,  If they don't we set *aFound to
-// PR_FALSE and return a minimal nsIMIMEInfo structure.
 already_AddRefed<nsIMIMEInfo>
 nsOSHelperAppService::GetMIMEInfoFromOS(const nsACString& aMIMEType,
                                         const nsACString& aFileExt,
                                         PRBool * aFound)
 {
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
-
   *aFound = PR_FALSE;
-
-  const nsCString& flatType = PromiseFlatCString(aMIMEType);
-  const nsCString& flatExt = PromiseFlatCString(aFileExt);
-
-  PR_LOG(mLog, PR_LOG_DEBUG, ("Mac: HelperAppService lookup for type '%s' ext '%s'\n",
-                              flatType.get(), flatExt.get()));
-
-  // Create a Mac-specific MIME info so we can use Mac-specific members.
-  nsMIMEInfoMac* mimeInfoMac = new nsMIMEInfoMac(aMIMEType);
-  if (!mimeInfoMac)
-    return nsnull;
-  NS_ADDREF(mimeInfoMac);
-
-  NSAutoreleasePool *localPool = [[NSAutoreleasePool alloc] init];
-
-  OSStatus err;
-  PRBool haveAppForType = PR_FALSE;
-  PRBool haveAppForExt = PR_FALSE;
-  PRBool typeAppIsDefault = PR_FALSE;
-  PRBool extAppIsDefault = PR_FALSE;
-  FSRef typeAppFSRef;
-  FSRef extAppFSRef;
-
-  if (!aMIMEType.IsEmpty()) {
-    CFURLRef appURL = NULL;
-    // CFStringCreateWithCString() can fail even if we're not out of memory --
-    // for example if the 'cStr' parameter is something very wierd (like "ÿÿ~"
-    // aka "\xFF\xFF~"), or possibly if it can't be interpreted as using what's
-    // specified in the 'encoding' parameter.  See bug 548719.
-    CFStringRef CFType = ::CFStringCreateWithCString(NULL, flatType.get(), kCFStringEncodingUTF8);
-    if (CFType) {
-      err = ::LSCopyApplicationForMIMEType(CFType, kLSRolesAll, &appURL);
-      if ((err == noErr) && appURL && ::CFURLGetFSRef(appURL, &typeAppFSRef)) {
-        haveAppForType = PR_TRUE;
-        PR_LOG(mLog, PR_LOG_DEBUG, ("LSCopyApplicationForMIMEType found a default application\n"));
-      }
-      if (appURL)
-        ::CFRelease(appURL);
-      ::CFRelease(CFType);
-    }
-  }
-  if (!aFileExt.IsEmpty()) {
-    // CFStringCreateWithCString() can fail even if we're not out of memory --
-    // for example if the 'cStr' parameter is something very wierd (like "ÿÿ~"
-    // aka "\xFF\xFF~"), or possibly if it can't be interpreted as using what's
-    // specified in the 'encoding' parameter.  See bug 548719.
-    CFStringRef CFExt = ::CFStringCreateWithCString(NULL, flatExt.get(), kCFStringEncodingUTF8);
-    if (CFExt) {
-      err = ::LSGetApplicationForInfo(kLSUnknownType, kLSUnknownCreator, CFExt,
-                                      kLSRolesAll, &extAppFSRef, nsnull);
-      if (err == noErr) {
-        haveAppForExt = PR_TRUE;
-        PR_LOG(mLog, PR_LOG_DEBUG, ("LSGetApplicationForInfo found a default application\n"));
-      }
-      ::CFRelease(CFExt);
-    }
-  }
-
-  if (haveAppForType && haveAppForExt) {
-    // Do aMIMEType and aFileExt match?
-    if (::FSCompareFSRefs((const FSRef *) &typeAppFSRef, (const FSRef *) &extAppFSRef) == noErr) {
-      typeAppIsDefault = PR_TRUE;
-      *aFound = PR_TRUE;
-    }
-  } else if (haveAppForType) {
-    // If aFileExt isn't empty, it doesn't match aMIMEType.
-    if (aFileExt.IsEmpty()) {
-      typeAppIsDefault = PR_TRUE;
-      *aFound = PR_TRUE;
-    }
-  } else if (haveAppForExt) {
-    // If aMIMEType isn't empty, it doesn't match aFileExt.
-    if (aMIMEType.IsEmpty()) {
-      extAppIsDefault = PR_TRUE;
-      *aFound = PR_TRUE;
-    }
-  }
-
-  if (aMIMEType.IsEmpty()) {
-    if (haveAppForExt) {
-      // If aMIMEType is empty and we've found a default app for aFileExt, try
-      // to get the MIME type from aFileExt.  (It might also be worth doing
-      // this when aMIMEType isn't empty but haveAppForType is false -- but
-      // the doc for this method says that if we have a MIME type (in
-      // aMIMEType), we need to give it preference.)
-      NSURLFileTypeMappings *map = [NSURLFileTypeMappings sharedMappings];
-      NSString *extStr = [NSString stringWithCString:flatExt.get() encoding:NSASCIIStringEncoding];
-      NSString *typeStr = map ? [map MIMETypeForExtension:extStr] : NULL;
-      if (typeStr) {
-        nsCAutoString mimeType;
-        mimeType.Assign((char *)[typeStr cStringUsingEncoding:NSASCIIStringEncoding]);
-        mimeInfoMac->SetMIMEType(mimeType);
-        haveAppForType = PR_TRUE;
-      } else {
-        // Sometimes the OS won't give us a MIME type for an extension that's
-        // registered with Launch Services and has a default app:  For example
-        // Real Player registers itself for the "ogg" extension and for the
-        // audio/x-ogg and application/x-ogg MIME types, but
-        // MIMETypeForExtension returns nil for the "ogg" extension even on
-        // systems where Real Player is installed.  This is probably an Apple
-        // bug.  But bad things happen if we return an nsIMIMEInfo structure
-        // with an empty MIME type and set *aFound to PR_TRUE.  So in this
-        // case we need to set it to PR_FALSE here.
-        haveAppForExt = PR_FALSE;
-        extAppIsDefault = PR_FALSE;
-        *aFound = PR_FALSE;
-      }
-    } else {
-      // Otherwise set the MIME type to a reasonable fallback.
-      mimeInfoMac->SetMIMEType(NS_LITERAL_CSTRING(APPLICATION_OCTET_STREAM));
-    }
-  }
-
-  if (typeAppIsDefault || extAppIsDefault) {
-    if (haveAppForExt)
-      mimeInfoMac->AppendExtension(aFileExt);
-
-    nsCOMPtr<nsILocalFileMac> app(do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
-    if (!app) {
-      NS_RELEASE(mimeInfoMac);
-      [localPool release];
-      return nsnull;
-    }
-
-    CFStringRef CFAppName = NULL;
-    if (typeAppIsDefault) {
-      app->InitWithFSRef(&typeAppFSRef);
-      ::LSCopyItemAttribute((const FSRef *) &typeAppFSRef, kLSRolesAll,
-                            kLSItemDisplayName, (CFTypeRef *) &CFAppName);
-    } else {
-      app->InitWithFSRef(&extAppFSRef);
-      ::LSCopyItemAttribute((const FSRef *) &extAppFSRef, kLSRolesAll,
-                            kLSItemDisplayName, (CFTypeRef *) &CFAppName);
-    }
-    if (CFAppName) {
-      nsAutoTArray<UniChar, 255> buffer;
-      CFIndex appNameLength = ::CFStringGetLength(CFAppName);
-      buffer.SetLength(appNameLength);
-      ::CFStringGetCharacters(CFAppName, CFRangeMake(0, appNameLength),
-                              buffer.Elements());
-      nsAutoString appName;
-      appName.Assign(buffer.Elements(), appNameLength);
-      mimeInfoMac->SetDefaultDescription(appName);
-      ::CFRelease(CFAppName);
-    }
-
-    mimeInfoMac->SetDefaultApplication(app);
-    mimeInfoMac->SetPreferredAction(nsIMIMEInfo::useSystemDefault);
-  } else {
-    mimeInfoMac->SetPreferredAction(nsIMIMEInfo::saveToDisk);
-  }
-
-  nsCAutoString mimeType;
-  mimeInfoMac->GetMIMEType(mimeType);
-  if (*aFound && !mimeType.IsEmpty()) {
-    // If we have a MIME type, make sure its preferred extension is included
-    // in our list.
-    NSURLFileTypeMappings *map = [NSURLFileTypeMappings sharedMappings];
-    NSString *typeStr = [NSString stringWithCString:mimeType.get() encoding:NSASCIIStringEncoding];
-    NSString *extStr = map ? [map preferredExtensionForMIMEType:typeStr] : NULL;
-    if (extStr) {
-      nsCAutoString preferredExt;
-      preferredExt.Assign((char *)[extStr cStringUsingEncoding:NSASCIIStringEncoding]);
-      mimeInfoMac->AppendExtension(preferredExt);
-    }
-
-    CFStringRef CFType = ::CFStringCreateWithCString(NULL, mimeType.get(), kCFStringEncodingUTF8);
-    CFStringRef CFTypeDesc = NULL;
-    if (::LSCopyKindStringForMIMEType(CFType, &CFTypeDesc) == noErr) {
-      nsAutoTArray<UniChar, 255> buffer;
-      CFIndex typeDescLength = ::CFStringGetLength(CFTypeDesc);
-      buffer.SetLength(typeDescLength);
-      ::CFStringGetCharacters(CFTypeDesc, CFRangeMake(0, typeDescLength),
-                              buffer.Elements());
-      nsAutoString typeDesc;
-      typeDesc.Assign(buffer.Elements(), typeDescLength);
-      mimeInfoMac->SetDescription(typeDesc);
-    }
-    if (CFTypeDesc)
-      ::CFRelease(CFTypeDesc);
-    ::CFRelease(CFType);
-  }
-
-  PR_LOG(mLog, PR_LOG_DEBUG, ("OS gave us: type '%s' found '%i'\n", mimeType.get(), *aFound));
-
-  [localPool release];
-  return mimeInfoMac;
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
+  return nsnull;
 }
 
 NS_IMETHODIMP
@@ -449,27 +102,6 @@
                                                    PRBool *found,
                                                    nsIHandlerInfo **_retval)
 {
-  NS_ASSERTION(!aScheme.IsEmpty(), "No scheme was specified!");
-
-  nsresult rv = OSProtocolHandlerExists(nsPromiseFlatCString(aScheme).get(),
-                                        found);
-  if (NS_FAILED(rv))
-    return rv;
-
-  nsMIMEInfoMac *handlerInfo =
-    new nsMIMEInfoMac(aScheme, nsMIMEInfoBase::eProtocolInfo);
-  NS_ENSURE_TRUE(handlerInfo, NS_ERROR_OUT_OF_MEMORY);
-  NS_ADDREF(*_retval = handlerInfo);
-
-  if (!*found) {
-    // Code that calls this requires an object regardless if the OS has
-    // something for us, so we return the empty object.
-    return NS_OK;
-  }
-
-  nsAutoString desc;
-  GetApplicationDescription(aScheme, desc);
-  handlerInfo->SetDefaultDescription(desc);
-
+  *found = PR_FALSE;
   return NS_OK;
 }
